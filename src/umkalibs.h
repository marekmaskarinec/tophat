#ifndef UMKALIBS_H
#define UMKALIBS_H
const char *libs[] = {
"\n"
"import (\n"
"	\"image.um\"\n"
"	\"rectangle.um\"\n"
")\n"
"\n"
"type anim* = struct {\n"
"	anim: []image.img\n"
"	rot: real\n"
"	scale: real\n"
"	fps: int\n"
"	looping: bool\n"
"\n"
"	px: real\n"
"	py: real \n"
"\n"
"	zerotime: int\n"
"\n"
"	frame: int\n"
"}\n"
"\n"
"fn mk*(px, py: int32, anm: []image.img, fps: int): anim {\n"
"	a := anim{}\n"
"\n"
"	a.anim = append(anm, anm[len(anm)-1])\n"
"\n"
"	a.fps = fps\n"
"	a.scale = 1\n"
"	a.rot = 0\n"
"\n"
"	a.px = px\n"
"	a.py = py\n"
"\n"
"	a.looping = false\n"
"\n"
"	return a\n"
"}\n"
"\n"
"fn (a: ^anim) start*(t: int) {\n"
"	a.zerotime = t\n"
"}\n"
"\n"
"fn (a: ^anim) handle*(t: int, cam: rectangle.rect): bool {\n"
"	a.frame = (round(real(t-a.zerotime)/round((1000.0/a.fps))) % len(a.anim))\n"
"\n"
"	a.anim[a.frame].draw(round(a.px) - cam.x + cam.w/2, round(a.py) - cam.y + cam.h/2, round(a.rot), a.scale)\n"
"\n"
"	if a.frame == len(a.anim) - 1 {\n"
"		if a.looping {\n"
"			a.zerotime = t\n"
"		} else {\n"
"			return true\n"
"		}\n"
"	}\n"
"\n"
"	return false\n"
"}\n"
"\n"
,
"// vim: filetype=umka\n"
"\n"
"type sound* = struct {\n"
"	handle: int\n"
"}\n"
"\n"
"var sarr*: []sound\n"
"\n"
"fn setsounds*(ss: []sound)\n"
"\n"
"fn cauload(path: str): int\n"
"\n"
"fn cauarr(s: ^sound, count: int32)\n"
"\n"
"fn csoundloop(s: int, looping: int32)\n"
"\n"
"fn csoundplay(s: int)\n"
"\n"
"fn csoundstop(s: int)\n"
"\n"
"fn csoundvol(s: int, vol: real)\n"
"\n"
"fn csoundvalidate(s: int): int\n"
"\n"
"fn load*(path: str): sound {\n"
"	s := sound{cauload(path)}\n"
"\n"
"	if len(sarr) == 0 {\n"
"		sarr = []sound{}\n"
"	}\n"
"\n"
"	sarr = append(sarr, s)\n"
"	setsounds(sarr)\n"
"\n"
"	return s\n"
"}\n"
"\n"
"fn setsounds*(ss: []sound) {\n"
"	cauarr(&ss[0], len(ss))\n"
"}\n"
"\n"
"fn (s: ^sound) looping*(l: bool) {\n"
"	if l {\n"
"		csoundloop(s.handle, 1)\n"
"		return\n"
"	}\n"
"\n"
"	csoundloop(s.handle, 0)\n"
"}\n"
"\n"
"fn (s: ^sound) play*() {\n"
"	csoundplay(s.handle)\n"
"}\n"
"\n"
"fn (s: ^sound) stop*() {\n"
"	csoundstop(s.handle)\n"
"}\n"
"\n"
"fn (s: ^sound) vol*(vol: real) {\n"
"	csoundvol(s.handle, vol)\n"
"}\n"
"\n"
"fn (s: ^sound) validate*(): bool {\n"
"	return bool(csoundvalidate(s.handle))\n"
"}\n"
"\n"
,
"// vim: filetype=umka\n"
"\n"
"import (\n"
"	\"polygon.um\"\n"
"	\"tophat.um\"\n"
"	\"rectangle.um\"\n"
"	\"std/std.um\"\n"
"	\"image.um\"\n"
")\n"
"\n"
"type ent* = struct {\n"
"	p: polygon.poly\n"
"	image: image.img\n"
"	sx: real\n"
"	sy: real\n"
"	rot: real \n"
"	color: uint32\n"
"	id: int32\n"
"}\n"
"\n"
"type cent* = struct {\n"
"	p: ^polygon.cpoly\n"
"	image: image.img\n"
"	sx: real\n"
"	sy: real\n"
"	rot: int32	\n"
"	color: uint32\n"
"	id: int32\n"
"}\n"
"\n"
"//fn (e: ^ent) getcoll(s: scene.scn)\n"
"\n"
"fn centdraw(e: cent, c: rectangle.rect)\n"
"\n"
"fn (e: ^ent) draw*(c: rectangle.rect) {\n"
"	cp := polygon.cpoly{round(e.p.x), round(e.p.y), &e.p.v[0], e.p.w, e.p.h, e.p.vc}\n"
"	ce := cent{&cp, e.image, e.sx, e.sy, round(e.rot), e.color, e.id}\n"
"\n"
"	centdraw(ce, c)\n"
"}\n"
"\n"
"fn cgetcoll(count: int32, e: ^cent, s: ^^cent): int32\n"
"\n"
"fn mk*(p: polygon.poly, color: uint32, id: int32): ent {\n"
"	if id == 0 {\n"
"		id = std.rand() + 1\n"
"	}\n"
"\n"
"	var e: ent\n"
"	e.p = p\n"
"	e.image = image.img{0}\n"
"	e.sx = 1\n"
"	e.sy = 1\n"
"	e.rot = 0\n"
"	e.color = color\n"
"	e.id = id\n"
"\n"
"	return e\n"
"}\n"
"\n"
"fn (e: ^ent) setrot*(rot: real) {\n"
"	e.rot = rot\n"
"	e.p.transform(e.sx, e.sy, round(rot))\n"
"}\n"
"\n"
"fn (e: ^ent) setscale*(sx, sy: real) {\n"
"	e.sx = sx\n"
"	e.sy = sy\n"
"	e.p.transform(sx, sy, round(e.rot))\n"
"}\n"
"\n"
"fn (e: ^ent) getcoll*(s: []^ent): int32 {\n"
"\n"
"	if len(s) == 0 {\n"
"		return 0\n"
"	}\n"
"\n"
"	cscn := []cent{}\n"
"	cps := []polygon.cpoly{}\n"
"\n"
"	for e in s {\n"
"		cps = append(cps, []polygon.cpoly{polygon.cpoly{round(e.p.x), round(e.p.y), &e.p.v[0], e.p.w, e.p.h, e.p.vc}})\n"
"		ce := cent{null, e.image, e.sx, e.sy, round(e.rot), e.color, e.id}\n"
"		cscn = append(cscn, []cent{ce})\n"
"	}\n"
"\n"
"	cscnp := []^cent{}\n"
"\n"
"	for i:=0; i < len(cps); i++ {\n"
"		cscn[i].p = &cps[i]\n"
"		cscnp = append(cscnp, &cscn[i])\n"
"	}\n"
"\n"
"	cp := polygon.cpoly{round(e.p.x), round(e.p.y), &e.p.v[0], e.p.w, e.p.h, e.p.vc}\n"
"	ce := cent{&cp, e.image, e.sx, e.sy, round(e.rot), e.color, e.id}\n"
"	return cgetcoll(len(cscnp), &ce, &cscnp[0])\n"
"}\n"
"\n"
"fn (e: ^ent) animate*(fps: int, anim: ^[]image.img) {\n"
"	e.image = anim^[(round(real(tophat.t)/(1000/fps)) % len(anim^))]\n"
"}\n"
"\n"
,
"\n"
"import (\n"
"	\"rawdraw.um\"\n"
")\n"
"\n"
"type img* = struct {\n"
"	handle: int\n"
"}\n"
"\n"
"fn loadimg(path: ^char): int\n"
"\n"
"fn deleteimg(i: int)\n"
"\n"
"fn iconset(i: int)\n"
"\n"
"fn flipvimg(i: int)\n"
"\n"
"fn fliphimg(i: int)\n"
"\n"
"fn imgvalid(i: int): int32\n"
"\n"
"fn imggetdims(w, h: ^int32, i: int)\n"
"\n"
"fn load*(path: str): img {\n"
"	return img{loadimg(&path[0])}\n"
"}\n"
"\n"
"fn (i: ^img) delete*() {\n"
"	deleteimg(i.handle)\n"
"}\n"
"\n"
"fn (i: ^img) setasicon*() {\n"
"	iconset(i.handle)\n"
"}\n"
"\n"
"fn (i: ^img) flipv*() {\n"
"	flipvimg(i.handle)\n"
"}\n"
"\n"
"fn (i: ^img) fliph*() {\n"
"	fliphimg(i.handle)\n"
"}\n"
"\n"
"fn (i: ^img) draw*(x, y, rot: int32, scale: real)  {\n"
"	rawdraw.cdrawimage(i.handle, rot, scale, x, y)\n"
"}\n"
"\n"
"fn (i: ^img) validate*(): bool {\n"
"	return bool(imgvalid(i.handle))\n"
"}\n"
"\n"
"fn (i: ^img) getdims*(): (int32, int32) {\n"
"	var w, h: int32\n"
"	imggetdims(&w, &h, i.handle)\n"
"\n"
"	return w, h\n"
"}\n"
"\n"
,
"// vim: filetype=umka\n"
"\n"
"import (\n"
"	\"std/std.um\"\n"
"	\"rectangle.um\"\n"
")\n"
"\n"
"var (\n"
"	KEY_BACKSPACE*: int32 = 0\n"
"	KEY_ESCAPE*: int32 = 1\n"
"	KEY_ENTER* : int32= 2\n"
"	ARROW_UP* : int32= 3\n"
"	ARROW_DOWN* : int32= 4\n"
"	ARROW_LEFT*: int32 = 5\n"
"	ARROW_RIGHT*: int32 = 6\n"
"	LMB*: int32 = 7\n"
"	MMB*: int32 = 8\n"
"	RMB*: int32 = 9\n"
"	KEY_0*: int32 = 48\n"
"	KEY_1*: int32 = 49\n"
"	KEY_2*: int32 = 50\n"
"	KEY_3*: int32 = 51\n"
"	KEY_4*: int32 = 52\n"
"	KEY_5*: int32 = 53\n"
"	KEY_6*: int32 = 54\n"
"	KEY_7*: int32 = 55\n"
"	KEY_8*: int32 = 56\n"
"	KEY_9*: int32 = 57\n"
"	KEY_A*: int32 = 97\n"
"	KEY_B*: int32 = 98\n"
"	KEY_C*: int32 = 99\n"
"	KEY_D*: int32 = 100\n"
"	KEY_E*: int32 = 101\n"
"	KEY_F*: int32 = 102\n"
"	KEY_G*: int32 = 103\n"
"	KEY_H*: int32 = 104\n"
"	KEY_I*: int32 = 106\n"
"	KEY_K*: int32 = 107\n"
"	KEY_L*: int32 = 108\n"
"	KEY_M*: int32 = 109\n"
"	KEY_N*: int32 = 110\n"
"	KEY_O*: int32 = 111\n"
"	KEY_P*: int32 = 112\n"
"	KEY_Q*: int32 = 113\n"
"	KEY_R*: int32 = 114\n"
"	KEY_S*: int32 = 115\n"
"	KEY_T*: int32 = 116\n"
"	KEY_U*: int32 = 117\n"
"	KEY_V*: int32 = 118\n"
"	KEY_W*: int32 = 119\n"
"	KEY_X*: int32 = 120\n"
"	KEY_Y*: int32 = 121\n"
"	KEY_Z*: int32 = 122\n"
"	KEY_MINUS*: int32 = 45\n"
"	KEY_PlUS*: int32 = 61\n"
"	KEY_SPACE*: int32 = 32\n"
")\n"
"\n"
"fn setwinmap*() {\n"
"	KEY_BACKSPACE = 8\n"
"	KEY_ESCAPE = 27\n"
"	KEY_ENTER = 13\n"
"	ARROW_UP = 38\n"
"	ARROW_DOWN = 40\n"
"	ARROW_LEFT = 37\n"
"	ARROW_RIGHT = 39\n"
"	KEY_0 = 48\n"
"	KEY_1 = 49\n"
"	KEY_2 = 50\n"
"	KEY_3 = 51\n"
"	KEY_4 = 52\n"
"	KEY_5 = 53\n"
"	KEY_6 = 54\n"
"	KEY_7 = 55\n"
"	KEY_8 = 56\n"
"	KEY_9 = 57\n"
"	KEY_A = 97\n"
"	KEY_B = 98\n"
"	KEY_C = 99\n"
"	KEY_D = 100\n"
"	KEY_E = 101\n"
"	KEY_F = 102\n"
"	KEY_G = 103\n"
"	KEY_H = 104\n"
"	KEY_I = 106\n"
"	KEY_K = 107\n"
"	KEY_L = 108\n"
"	KEY_M = 109\n"
"	KEY_N = 110\n"
"	KEY_O = 111\n"
"	KEY_P = 112\n"
"	KEY_Q = 113\n"
"	KEY_R = 114\n"
"	KEY_S = 115\n"
"	KEY_T = 116\n"
"	KEY_U = 117\n"
"	KEY_V = 118\n"
"	KEY_W = 119\n"
"	KEY_X = 120\n"
"	KEY_Y = 121\n"
"	KEY_Z = 122\n"
"	KEY_MINUS = 45\n"
"	KEY_PlUS = 61\n"
"	KEY_SPACE = 32\n"
"}\n"
"\n"
"fn cgetmouse(x, y: ^int32)\n"
"\n"
"fn getmousepos*(): (int32, int32) {\n"
"	var w, h: int32\n"
"\n"
"	cgetmouse(&w, &h)\n"
"\n"
"	return w, h\n"
"}\n"
"\n"
"fn getglobalmousepos*(cam: rectangle.rect): (int32, int32) {\n"
"	w, h := getmousepos()\n"
"\n"
"	return w + cam.x - cam.w/2, h + cam.y - cam.h/2	\n"
"}\n"
"\n"
"fn cispressed(keycode: int32): int32\n"
"\n"
"fn cisjustpressed(key: int32): int32\n"
"\n"
"fn ispressed*(code: int32): bool {\n"
"	val := bool(cispressed(code))\n"
"	return val\n"
"}\n"
"\n"
"fn isjustpressed*(code: int32): bool {\n"
"	return bool(cisjustpressed(code))\n"
"}\n"
"\n"
,
"\n"
"import \"std/std.um\"\n"
"\n"
"type mp* = struct {\n"
"	size: int\n"
"	vals: []str\n"
"}\n"
"\n"
"fn mk*(size: int): mp {\n"
"	vals := make([]str, size)\n"
"	m := mp{size, []str{}}\n"
"	return m\n"
"}\n"
"\n"
"fn hash(s: str, size: int): int {\n"
"	var val: int\n"
"\n"
"	for c in s {\n"
"		val += (uint32(c) * 238) % size\n"
"	}\n"
"\n"
"	return val\n"
"}\n"
"\n"
"fn (m: ^mp) setstr*(key, val: str) {\n"
"	m.vals[hash(key, m.size)] = val\n"
"}\n"
"\n"
"fn (m: ^mp) setint*(key: str, val: int) {\n"
"	m.setstr(key, std.itoa(val))\n"
"}\n"
"\n"
"fn (m: ^mp) getstr*(key: str): str {\n"
"	return m.vals[hash(key, m.size)]\n"
"}\n"
"\n"
"fn (m: ^mp) getint*(key: str): int {\n"
"	return std.atoi(m.getstr(key))\n"
"}\n"
"\n"
"fn (m: ^mp) delete*(key: str) {\n"
"	m.vals[hash(key, m.size)] = \"\"\n"
"}\n"
"\n"
,
"import \"std/std.um\"\n"
"\n"
"fn stepify*(val, step: real): real {\n"
"	if step != 0 {\n"
"		val = trunc(val / step + 0.5) * step\n"
"	}\n"
"	return val\n"
"}\n"
"\n"
"// TODO: better sort\n"
"fn ysort*(ents: []entity.ent): []entity.ent {\n"
"	swapped := true\n"
"\n"
"	for swapped {\n"
"		swapped = false\n"
"\n"
"		for i:=1; i < len(ents); i++ {\n"
"			if ents[i-1].p.y > ents[i].p.y {\n"
"				tmp := ents[i]\n"
"				ents[i] = ents[i-1]\n"
"				ents[i-1] = tmp\n"
"\n"
"				swapped = true\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	return ents\n"
"}\n"
"\n"
,
"// vim: filetype=umka\n"
"\n"
"import (\n"
"	\"std/std.um\"\n"
"	\"vec.um\"\n"
"	\"rawdraw.um\"\n"
")\n"
"type poly* = struct {\n"
"    x: real\n"
"    y: real\n"
"    v: []int32\n"
"		rv: []int32\n"
"		rw: int32\n"
"		rh: int32\n"
"    w: int32\n"
"    h: int32\n"
"    vc: int32\n"
"}\n"
"\n"
"type cpoly* = struct {\n"
"	x: int32\n"
"	y: int32\n"
"	v: ^int32\n"
"	w: int32\n"
"	h: int32\n"
"	vc: int32\n"
"}\n"
"\n"
"fn mk*(x, y: real, v: []int32): poly {\n"
"	var p: poly\n"
"\n"
"	p.vc = int32(len(v)/2)\n"
"	p.v = v\n"
"	p.x = x\n"
"	p.y = y\n"
"\n"
"	var maxx, maxy: int32;\n"
"\n"
"	for i:=0; i < len(v); i += 2 {\n"
"		if v[i] > maxx { maxx = v[i] }\n"
"		\n"
"		if v[i + 1] > maxy { maxy = v[i + 1] }\n"
"	}\n"
"\n"
"	p.w = maxx\n"
"	p.h = maxy\n"
"	p.rw = p.w\n"
"	p.rh = p.h\n"
"	p.rv = v\n"
"\n"
"	return p\n"
"}\n"
"\n"
"fn (p: ^poly) transform*(sx, sy: real, rot: int32) {\n"
"	var x, y, cx, cy: int32\n"
"\n"
"	cx = round(p.w/2 * sx)\n"
"	cy = round(p.h/2 * sy)\n"
"	\n"
"	var w, h: int32\n"
"\n"
"	v := []int32{}\n"
"\n"
"	for i:=0; i<len(p.v); i+=2 {\n"
"\n"
"		x = round(p.rv[i] * sx)\n"
"		y = round(p.rv[i+1] * sy)\n"
"\n"
"		tx, ty := vec.rotatepoint(real(x), real(y), cx, cy, rot)\n"
"\n"
"		x, y = vec.rnd(tx, ty)\n"
"\n"
"		if x > w {\n"
"			w = x\n"
"		}\n"
"		if y > h {\n"
"			h = y\n"
"		}\n"
"\n"
"		v = append(v, []int32{round(x), round(y)})\n"
"	}\n"
"\n"
"	p.v = v\n"
"	p.w = w\n"
"	p.h = h\n"
"}\n"
"\n"
"fn cdrawpoly*(color: uint32, p: ^polygon.cpoly)\n"
"\n"
"fn (p: ^poly) draw*(color: uint32) {\n"
"	cp := polygon.cpoly{round(p.x), round(p.y), &p.v[0], p.w, p.h, p.vc}\n"
"\n"
"	cdrawpoly(color, &cp)\n"
"}\n"
"\n"
,
"import (\n"
"	\"std/std.um\"\n"
"	\"polygon.um\"\n"
")\n"
"\n"
"fn drawtext*(text: str, x: int32, y: int32, color: uint32, size: real)\n"
"\n"
"fn textsize*(text: str, scale: real): (int, int) {\n"
"	var w, maxw, h: int\n"
"	w = 0\n"
"	maxw = 0\n"
"	h = 1\n"
"\n"
"	for s in text {\n"
"		if s == \"\\n\" {\n"
"			h += 1\n"
"			if w > maxw {\n"
"				maxw = w\n"
"			}\n"
"\n"
"			continue\n"
"		}\n"
"\n"
"		w++\n"
"	}\n"
"\n"
"	if w > maxw {\n"
"		maxw = w\n"
"	}\n"
"\n"
"	return round(maxw * scale * 3 - scale), round(h * 6 * scale)\n"
"}\n"
"\n"
"fn setup*(title: str, w, h: int)\n"
"\n"
"fn setbgcolor*(color: int)\n"
"\n"
"fn setcolor*(color: int)\n"
"\n"
"fn clearframe*()\n"
"\n"
"fn getdimensions*(w, h: ^int32)\n"
"\n"
"fn swapbuffers*()\n"
"\n"
"fn handleinput*()\n"
"\n"
"fn drawsegment*(x1, y1, x2, y2: int32)\n"
"\n"
"fn drawrect*(x1, y1, x2, y2: int32)\n"
"\n"
"fn drawline*(x1, y1, x2, y2, s: int32, color: uint32) {\n"
"	setcolor(color)\n"
"	drawsegment(x1, y1, x2, y2)\n"
"}\n"
"\n"
"fn cdrawimage*(img: int, rot: int32, scale: real, x, y: int32)\n"
"\n"
,
"// vim: filetype=umka\n"
"\n"
"import (\n"
"	\"entity.um\"\n"
"	\"polygon.um\"\n"
")\n"
"\n"
"type ray* = struct {\n"
"	x: real\n"
"	y: real\n"
"	l: int32\n"
"	r: real\n"
"}\n"
"\n"
"type cray = struct {\n"
"	x: int32\n"
"	y: int32\n"
"	l: int32\n"
"	r: int32\n"
"}\n"
"\n"
"fn mk*(x, y, l, r: int32): ray {\n"
"	return ray{x, y, l, r}\n"
"}\n"
"\n"
"fn craygetcoll(count: int32, r: ^cray, s: ^^entity.cent): int32\n"
"\n"
"fn (r: ^ray) getcoll*(s: []^entity.ent): int32 {\n"
"	cscn := []entity.cent{}\n"
"	cps := []polygon.cpoly{}\n"
"\n"
"	for e in s {\n"
"		cps = append(cps, []polygon.cpoly{polygon.cpoly{round(e.p.x), round(e.p.y), &e.p.v[0], e.p.w, e.p.h, e.p.vc}})\n"
"		ce := entity.cent{null, e.image, e.sx, e.sy, round(e.rot), e.color, e.id}\n"
"		cscn = append(cscn, []entity.cent{ce})\n"
"	}\n"
"\n"
"	cscnp := []^entity.cent{}\n"
"\n"
"	for i:=0; i < len(cps); i++ {\n"
"		cscn[i].p = &cps[i]\n"
"		cscnp = append(cscnp, &cscn[i])\n"
"	}\n"
"\n"
"	cr := cray{round(r.x), round(r.y), r.l, round(r.r)}\n"
"\n"
"	return craygetcoll(len(cscnp), &cr, &cscnp[0])\n"
"}\n"
"\n"
"\n"
,
"\n"
"type rect* = struct {\n"
"	x: int32\n"
"	y: int32\n"
"	w: int32\n"
"	h: int32\n"
"}\n"
"\n"
"fn mk*(x, y, w, h: int32): rect {\n"
"	var r: rect\n"
"\n"
"	r.x = x\n"
"	r.y = y\n"
"	r.w = w\n"
"	r.h = h\n"
"\n"
"	return r\n"
"}\n"
"\n"
,
"// vim: filetype=umka\n"
"\n"
"import (\n"
"	\"rawdraw.um\"\n"
"	\"rectangle.um\"\n"
"	\"input.um\"\n"
"	\"audio.um\"\n"
"	\"std/std.um\"\n"
")\n"
"\n"
"var t*, start, end, delta*: int\n"
"\n"
"var platform*: str = \"linux\"\n"
"\n"
"fn sleep*(t: int)\n"
"\n"
"fn gettime*(): int\n"
"\n"
"fn setup*(title: str, w, h: int32) {\n"
"	rawdraw.setup(title, w, h)\n"
"	rawdraw.setbgcolor(0x000000ff)\n"
"	rawdraw.clearframe()\n"
"\n"
"	if std.getenv(\"HOME\") == \"\" {\n"
"		input.setwinmap()\n"
"		platform = \"windows\"\n"
"	}\n"
"\n"
"	audio.sarr = []audio.sound{}\n"
"\n"
"	t = gettime()\n"
"}\n"
"\n"
"fn setwindowtitle*(title: str)\n"
"\n"
"fn debug*()\n"
"fn debug2*()\n"
"\n"
"fn visualizecam(w, h: int32, color: uint32)\n"
"\n"
"fn updatescaling(w, h, camw, camh: int32)\n"
"\n"
"fn cycle*(w, h: ^int32, bgcolor: uint32, cam: rectangle.rect) {\n"
"	rawdraw.setcolor(0x000000ff)\n"
"	rawdraw.drawrect(0, cam.h, w^, h^)\n"
"	rawdraw.drawrect(cam.w, 0, w^, h^)\n"
"	rawdraw.swapbuffers()\n"
"\n"
"	end = gettime()/1000\n"
"	delta = (end - start)\n"
"	if delta < 0 {\n"
"		delta += 1000\n"
"	}\n"
"	start = gettime()/1000\n"
"	t += delta\n"
"\n"
"	rawdraw.setbgcolor(0x000000ff)\n"
"	rawdraw.clearframe()\n"
"	rawdraw.handleinput()\n"
"	rawdraw.getdimensions(w, h)\n"
"	var ws, hs: int32\n"
"	rawdraw.getdimensions(&ws, &hs)\n"
"\n"
"	updatescaling(ws, hs, cam.w, cam.h)\n"
"\n"
"	visualizecam(cam.w, cam.h, bgcolor)\n"
"}\n"
"\n"
"fn setvsync*(v: bool)\n"
"\n"
"\n"
,
"\n"
"import (\n"
"	\"rectangle.um\"\n"
"	\"rawdraw.um\"\n"
"	\"input.um\"\n"
"	\"tophat.um\"\n"
"	\"image.um\"\n"
")\n"
"\n"
"const (\n"
"	// text aligns\n"
"	TOP* = 0\n"
"	MID* = 1\n"
"	BOT* = 2\n"
"\n"
"	// image modes\n"
"	CENTER* = 3\n"
"	STRETCH* = 4\n"
"	SCALE* = 5\n"
")\n"
"\n"
"type element* = interface {\n"
"	draw()\n"
"	calculate()\n"
"	handle()\n"
"	gspan(): ^int\n"
"	gpadding(): ^rectangle.rect\n"
"	gdimensions(): ^rectangle.rect\n"
"}\n"
"\n"
"type box* = struct {\n"
"	children: []element\n"
"	padding, dimensions: rectangle.rect\n"
"	span: int\n"
"	vertical: bool \n"
"\n"
"	image: image.img\n"
"	imagemode: int\n"
"	imgs: int\n"
"	imgx, imgy: int\n"
"}\n"
"\n"
"type label* = struct {\n"
"	text: str\n"
"	textsize: real\n"
"	textcolor: uint32\n"
"	valign: int\n"
"	halign: int\n"
"	bgcolor: uint32\n"
"	padding, dimensions: rectangle.rect\n"
"	span: int\n"
"}\n"
"\n"
"type button* = struct {\n"
"	label: label\n"
"	toggled: bool\n"
"	pressed: bool\n"
"	justpressed: bool\n"
"	clickfunc: bool\n"
"\n"
"	padding, dimensions: rectangle.rect\n"
"	span: int\n"
"\n"
"	onpress, onjustpress: fn()\n"
"	ontoggle: fn(toggled: bool)\n"
"}\n"
"\n"
"////////////////////////////////\n"
"// box\n"
"\n"
"fn mkbox*(c: []element, vertical: bool): box {\n"
"	h := box {}\n"
"\n"
"	h.padding = rectangle.mk(0, 0, 0, 0)\n"
"	h.children = c\n"
"	h.dimensions = rectangle.mk(0, 0, 0, 0)\n"
"	h.span = 1\n"
"	h.vertical = vertical\n"
"\n"
"	return h\n"
"}\n"
"\n"
"fn (b: ^box) calculate*() {\n"
"\n"
"	totalspan := 0.0\n"
"	off := 0\n"
"\n"
"	for i:=0; i < len(b.children); i++ {\n"
"		totalspan += b.children[i].gspan()^\n"
"	}\n"
"\n"
"	for i:=0; i < len(b.children); i++ {\n"
"\n"
"		if b.vertical {\n"
"			dims := b.children[i].gdimensions()\n"
"			padd := b.children[i].gpadding()\n"
"      \n"
"			dims.x = b.dimensions.x + off + padd.x\n"
"			dims.w = round(real(b.dimensions.w)/totalspan) * b.children[i].gspan()^ - padd.w\n"
"      \n"
"			dims.y = b.dimensions.y + padd.y\n"
"			dims.h = b.dimensions.h - padd.h\n"
"      \n"
"			b.children[i].calculate()\n"
"      \n"
"			off += round(real(b.dimensions.w)/totalspan) * b.children[i].gspan()^\n"
"		\n"
"		} else {\n"
"			dims := b.children[i].gdimensions()\n"
"			padd := b.children[i].gpadding()\n"
"      \n"
"			dims.x = b.dimensions.x + padd.x\n"
"			dims.w = b.dimensions.w - padd.w - padd.x\n"
"      \n"
"			dims.y = b.dimensions.y + off + padd.y\n"
"			dims.h = round(real(b.dimensions.h)/totalspan * b.children[i].gspan()^) - padd.h - padd.y\n"
"      \n"
"			b.children[i].calculate()\n"
"      \n"
"			off += round(real(b.dimensions.h)/totalspan) * b.children[i].gspan()^\n"
"		}\n"
"	}\n"
"\n"
"	if b.image.handle == 0 {\n"
"		return\n"
"	}\n"
"\n"
"	switch b.imagemode {\n"
"	case CENTER:\n"
"		b.imgs = 1\n"
"\n"
"		w, h := b.image.getdims()\n"
"\n"
"		b.imgx = b.dimensions.x + (b.dimensions.w-w)/2\n"
"		b.imgy = b.dimensions.y + (b.dimensions.h-h)/2\n"
"	case SCALE:\n"
"\n"
"		w, h = b.image.getdims()\n"
"\n"
"		sx := b.dimensions.w / w\n"
"		sy := b.dimensions.h / h\n"
"\n"
"		b.imgs = sy\n"
"\n"
"		if sx < sy {\n"
"			b.imgs = sx\n"
"		}\n"
"\n"
"		b.imgx = b.dimensions.x + (b.dimensions.w - w*b.imgs)/2\n"
"		b.imgy = b.dimensions.y + (b.dimensions.h - h*b.imgs)/2\n"
"	}\n"
"}\n"
"\n"
"fn (hb: ^box) draw*() {\n"
"\n"
"	if hb.image.handle != 0 {\n"
"		hb.image.draw(hb.imgx, hb.imgy, 0, hb.imgs)\n"
"	}\n"
"\n"
"	for i:=0; i < len(hb.children); i++ {\n"
"		hb.children[i].draw()\n"
"	}\n"
"}\n"
"\n"
"fn (hb: ^box) gspan*(): ^int {\n"
"	return &hb.span\n"
"}\n"
"\n"
"fn (hb: ^box) gpadding*(): ^rectangle.rect {\n"
"	return &hb.padding\n"
"}\n"
"\n"
"fn (hb: ^box) gdimensions*(): ^rectangle.rect {\n"
"	return &hb.dimensions\n"
"}\n"
"\n"
"fn (hb: ^box) handle*() {\n"
"	for i:=0; i < len(hb.children); i++ {\n"
"		hb.children[i].handle()\n"
"	}\n"
"}\n"
"\n"
"////////////////////////////////\n"
"// label\n"
"\n"
"fn mklabel*(text: str, textsize: real, textcolor: uint32): label {\n"
"	h := label {}\n"
"\n"
"	h.text = text\n"
"	h.textsize = textsize\n"
"	h.textcolor = textcolor\n"
"	h.bgcolor = 0x0\n"
"	h.padding = rectangle.mk(0, 0, 0, 0)\n"
"	h.dimensions = rectangle.mk(0, 0, 0, 0)\n"
"	h.span = 1\n"
"	h.valign = MID\n"
"	h.halign = MID\n"
"\n"
"	return h\n"
"}\n"
"\n"
"fn (l: ^label) calculate*() {\n"
"	sx, sy := rawdraw.textsize(l.text, l.textsize)\n"
"\n"
"	switch l.valign {\n"
"	case MID:\n"
"		l.padding.y = (l.dimensions.h-sy)/2\n"
"	case BOT:\n"
"		l.padding.y = l.dimensions.h - sy\n"
"	}\n"
"\n"
"	switch l.halign {\n"
"	case MID:\n"
"		l.padding.x = (l.dimensions.w-sx)/2\n"
"	case BOT:\n"
"		l.padding.x = l.dimensions.w - sx\n"
"	}\n"
"}\n"
"\n"
"fn (l: ^label) draw*() {\n"
"	rawdraw.setcolor(l.bgcolor)\n"
"	rawdraw.drawrect(l.dimensions.x - l.padding.x, l.dimensions.y - l.padding.y, l.dimensions.w + l.padding.w, l.dimensions.h + l.padding.h)\n"
"\n"
"	rawdraw.drawtext(l.text, l.dimensions.x, l.dimensions.y, l.textcolor, l.textsize)\n"
"}\n"
"\n"
"fn (l: ^label) gspan*(): ^int {\n"
"	return &l.span\n"
"}\n"
"\n"
"fn (l: ^label) gpadding*(): ^rectangle.rect {\n"
"	return &l.padding\n"
"}\n"
"\n"
"fn (l: ^label) gdimensions*(): ^rectangle.rect {\n"
"	return &l.dimensions\n"
"}\n"
"\n"
"fn (l: ^label) handle*() {}\n"
"\n"
"////////////////////////////////\n"
"// button\n"
"\n"
"fn mkbutton*(l: label): button {\n"
"	b := button{}\n"
"\n"
"	b.padding = l.padding\n"
"	b.label = l\n"
"	b.pressed = false\n"
"	b.justpressed = false\n"
"	b.toggled = false\n"
"	b.span = 1\n"
"\n"
"	b.onpress = fn() {}\n"
"	b.onjustpress = fn() {}\n"
"	b.ontoggle = fn(toggled: bool) {}\n"
"\n"
"	return b\n"
"}\n"
"\n"
"fn (b: ^button) calculate*() {\n"
"	b.label.dimensions = b.dimensions\n"
"	b.label.calculate()\n"
"	b.label.dimensions.x += b.label.padding.x\n"
"	b.label.dimensions.w -= b.label.padding.w\n"
"\n"
"	b.label.dimensions.y += b.label.padding.y\n"
"	b.label.dimensions.h -= b.label.padding.h\n"
"}\n"
"\n"
"fn (b: ^button) draw*() {\n"
"	b.label.draw()\n"
"}\n"
"\n"
"fn (b: ^button) gspan*(): ^int {\n"
"	return &b.span\n"
"}\n"
"\n"
"fn (b: ^button) gpadding*(): ^rectangle.rect {\n"
"	return &b.padding\n"
"}\n"
"\n"
"fn (b: ^button) gdimensions*(): ^rectangle.rect {\n"
"	return &b.dimensions\n"
"}\n"
"\n"
"fn (b: ^button) handle*() {\n"
"	mx, my := input.getmousepos()\n"
"	mp := input.ispressed(input.LMB)\n"
"\n"
"	ms := (b.dimensions.x <= mx && b.dimensions.y <= my && mx <= b.dimensions.x + b.dimensions.w && my <= b.dimensions.y + b.dimensions.h)\n"
"	//printf(\"%d, %d, %d, %d\\n\", b.dimensions.x, b.dimensions.y, b.dimensions.x + b.dimensions.w, b.dimensions.y + b.dimensions.h)\n"
"	//printf(\"%d, %d, %d, %d\\n\", mx, my, int(mp), int(ms))\n"
"\n"
"	b.justpressed = false\n"
"\n"
"	if ms && mp {\n"
"		if !b.pressed {\n"
"			b.justpressed = true\n"
"			b.onjustpress()\n"
"		}\n"
"		b.pressed = true\n"
"		b.onpress()\n"
"	} else {\n"
"		b.pressed = false\n"
"	}\n"
"\n"
"	if b.justpressed {\n"
"		b.toggled = !b.toggled\n"
"		b.ontoggle(b.toggled)\n"
"	}\n"
"\n"
"	//printf(\"%d\\n\", int(b.pressed))\n"
"}\n"
"\n"
"////////////////////////////////\n"
"// main handler\n"
"\n"
"var main*: element\n"
"\n"
"fn update*(w, h: int32) {\n"
"	dims := main.gdimensions()\n"
"	padd := main.gpadding()\n"
"	dims.x = padd.x\n"
"	dims.y = padd.y\n"
"	dims.w = w - padd.w - padd.x\n"
"	dims.h = h - padd.h - padd.y\n"
"	main.calculate()\n"
"}\n"
"\n"
"fn handle*(w, h: int32) {\n"
"	if tophat.t % 100 < 32 {\n"
"		update(w, h)\n"
"	}\n"
"\n"
"	main.handle()\n"
"	main.draw()\n"
"}\n"
"\n"
,
"\n"
"import \"std/std.um\"\n"
"\n"
"fn rotatepoint*(x, y, cx, cy, rot: real): (real, real) {\n"
"\n"
"	angle := (rot * std.pi) / 180\n"
"\n"
"	x1 := x - cx;\n"
"	y1 := y - cy;\n"
"\n"
"	x2 := x1 * cos(angle) - y1 * sin(angle);\n"
"	y2 := x1 * sin(angle) + y1 * cos(angle);\n"
"\n"
"	return x2 + cx, y2 + cy\n"
"}\n"
"\n"
"fn distanceto*(x1, y1, x2, y2: real): real { return std.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) }\n"
"\n"
"fn angleto*(x1, y1, x2, y2: real): real { return atan2(y2 - y1, x2 - x1) * 180 / std.pi + 180 }\n"
"\n"
"fn abs*(x, y: real): (real, real) { return fabs(x), fabs(y) }\n"
"\n"
"fn rnd*(x, y: real): (int32, int32) { return round(x), round(y) }\n"
"\n"
"fn flr*(x, y: real): (int32, int32) { return trunc(x), trunc(y) }\n"
"\n"
,
"// Umka standard library\n"
"\n"
"// File I/O\n"
"\n"
"type File* = ^struct {}\n"
"\n"
"const (\n"
"    seekBegin* = 0\n"
"    seekCur*   = 1\n"
"    seekEnd*   = 2\n"
")    \n"
"\n"
"fn rtlfopen  (name: str, mode: str): File;  \n"
"fn cfopen    (name: str, mode: str): File;\n"
"fn fopen*    (name: str, mode: str): File {return cfopen(name, mode)}\n"
"\n"
"fn rtlfclose (f: File): int\n"
"fn fclose*   (f: File): int {return rtlfclose(f)}\n"
"\n"
"fn rtlfread(buf: ^void, size, cnt: int, f: File): int\n"
"fn fread*(f: File, buf: interface{}): int {\n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot read reference types\")\n"
"    }\n"
"    return rtlfread(buf.__self, sizeofself(buf), 1, f)\n"
"}\n"
"\n"
"fn rtlfwrite(buf: ^void, size, cnt: int, f: File): int\n"
"fn fwrite*(f: File, buf: interface{}): int {\n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot write reference types\")\n"
"    }\n"
"    return rtlfwrite(buf.__self, sizeofself(buf), 1, f)\n"
"}\n"
"\n"
"fn rtlfseek  (f: File, offset, origin: int): int\n"
"fn fseek*    (f: File, offset, origin: int): int {return rtlfseek(f, offset, origin)}\n"
"\n"
"fn rtlremove (name: str): int\n"
"fn remove*   (name: str): int {return rtlremove(name)}\n"
"\n"
"// I/O utilities\n"
"\n"
"fn println*(s: str): int {return printf(\"%s\\n\", s)}\n"
"fn fprintln*(f: File, s: str): int {return fprintf(f, \"%s\\n\", s)}\n"
"\n"
"fn getchar*(): char {\n"
"    var c: char\n"
"    scanf(\"%c\", &c)\n"
"    return c\n"
"}\n"
"\n"
"// Conversions\n"
"\n"
"fn atoi*(s: str): int {\n"
"    var x: int\n"
"    sscanf(s, \"%lld\", &x)\n"
"    return x\n"
"}\n"
"\n"
"fn atof*(s: str): real {\n"
"    var x: real\n"
"    sscanf(s, \"%lf\", &x)\n"
"    return x\n"
"}\n"
"\n"
"fn itoa*(x: int): str {\n"
"    s := str(new([256]char))\n"
"    sprintf(s, \"%lld\", x)\n"
"    return s\n"
"}\n"
"\n"
"fn ftoa*(x: real, decimals: int): str {\n"
"    fmt := str(new([256]char))\n"
"    s := str(new([256]char))\n"
"    sprintf(fmt, \"%%.%dlf\", decimals)\n"
"    sprintf(s, fmt, x)\n"
"    return s\n"
"}\n"
"\n"
"// Math\n"
"\n"
"const pi* = 3.14159265358979323846\n"
"\n"
"// Random numbers\n"
"\n"
"const randMax* = 0x7FFFFFFF\n"
"randSeed := 0\n"
"\n"
"fn srand*(seed: int) {randSeed = seed}\n"
"\n"
"fn rand*(): int {\n"
"    randSeed = ((randSeed * 1103515245) + 12345) & 0x7FFFFFFF\n"
"    return randSeed\n"
"}\n"
"\n"
"fn frand*(): real {return real(rand()) / randMax}\n"
"\n"
"// Timer\n"
"\n"
"fn rtltime(): int\n"
"fn time*(): int {return rtltime()}\n"
"\n"
"fn rtlclock(): real\n"
"fn clock*(): real {return rtlclock()}\n"
"\n"
"// Command line and environment\n"
"\n"
"/*fn argc*(): int {return rtlargc}\n"
"\n"
"fn argv*(i: int): str {\n"
"    if i < 0 || i >= rtlargc {\n"
"        error(\"Command line parameter not found\")\n"
"    }\n"
"    return rtlargv[i]\n"
"}*/\n"
"\n"
"fn rtlgetenv(name: str): str\n"
"fn getenv*(name: str): str {\n"
"    return \"\" + rtlgetenv(name)\n"
"}\n"
"\n"
,
};
#endif
