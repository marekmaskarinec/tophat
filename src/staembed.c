#include "tophat.h" 
const char *th_em_modulesrc[] = {
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"atlas.um\"\n"
")\n"
"\n"
"//~~struct Anim\n"
"// Anim allows you to animate between individual frames of an atlas.\n"
"type Anim* = struct {\n"
"\t// the source atlas\n"
"\tatl: atlas.Atlas\n"
"\t// the first cell of the animation\n"
"\tmin: int\n"
"\t// the last cell of the animation\n"
"\tmax: int\n"
"\tfps: real32\n"
"\t// offset in time\n"
"\toffset: int\n"
"}\n"
"//~~\n"
"\n"
"//~~fn mk\n"
"// `Anim` constructor\n"
"fn mk*(atl: atlas.Atlas, fps: int, min: int = 0, max: int = -1 /* len(atl) - 1 */, offset: int = -1 /* th.time */): Anim {\n"
"//~~\n"
"\ta := Anim{}\n"
"\n"
"\ta.atl = atl\n"
"\ta.fps = fps\n"
"\ta.min = min\n"
"\tif max == -1 {\n"
"\t\ta.max = trunc(atl.dm.x * atl.dm.y) - 1\n"
"\t} else {\n"
"\t\ta.max = max\n"
"\t}\n"
"\n"
"\tif offset == -1 {\n"
"\t\ta.offset = th.time\n"
"\t} else {\n"
"\t\ta.offset = offset\n"
"\t}\n"
"\n"
"\treturn a\n"
"}\n"
"\n"
"//~~fn Anim.animate\n"
"// Crops the base atlas to the cell that should be visible at `time`.\n"
"fn (anm: ^Anim) animate*(time: int) {\n"
"//~~\n"
"\tn := (round(real(time-anm.offset)/round((1000.0/anm.fps))) % anm.max) + anm.min\n"
"\n"
"\tanm.atl.cropSource(anm.atl.coords(n))\n"
"}\n"
"\n"
"//~~fn Anim.framesPlayed\n"
"// Returns how many frames were played at `time`.\n"
"fn (anm: ^Anim) framesPlayed*(time: int): int {\n"
"//~~\n"
"\treturn trunc((time - anm.offset) / 1000.0 * anm.fps)\n"
"}\n"
"",
"//~~\n"
"// Module for audio loading and playback.\n"
"//~~\n"
"\n"
"//~~opaque Sound\n"
"// Represents an instance of a playable sound. It is an opaque structure.\n"
"type Sound* = struct { _: ^struct{} }\n"
"//~~\n"
"\n"
"var pool: []^Sound\n"
"\n"
"fn umth_sound_load(path: str): ^struct{}\n"
"//~~fn load\n"
"// Loads a sounds at path, if there is an error, the underlying pointer\n"
"// will be `NULL` and `validate` will return false.\n"
"fn load*(path: str): Sound {\n"
"//~~\n"
"\treturn Sound{umth_sound_load(path)}\n"
"}\n"
"\n"
"fn umth_sound_copy(s: Sound): ^struct{}\n"
"//~~fn Sound.copy\n"
"// Copies the sound. This will create another sound which can be configured\n"
"// and played independently from the original sound.\n"
"fn (s: ^Sound) copy*(): Sound {\n"
"//~~\n"
"\treturn Sound{umth_sound_copy(s^)}\n"
"}\n"
"\n"
"//~~fn Sound.validate\n"
"// Returns `true` if `s` loaded correctly.\n"
"fn (s: ^Sound) validate*(): bool {\n"
"//~~\n"
"\treturn s._ != null\n"
"}\n"
"\n"
"fn umth_sound_is_playing(s: Sound): bool\n"
"//~~fn Sound.isPlaying\n"
"// Returns true if the sound is still playing.\n"
"fn (s: ^Sound) isPlaying*(): bool {\n"
"//~~\n"
"\treturn umth_sound_is_playing(s^)\n"
"}\n"
"\n"
"fn umth_sound_play(s: Sound)\n"
"//~~fn Sound.play\n"
"// Plays the sound.\n"
"fn (s: ^Sound) play*() {\n"
"//~~\n"
"\tumth_sound_play(s^)\n"
"}\n"
"\n"
"//~~fn Sound.start\n"
"// The start function allows you to play a single sound multiple times.\n"
"// It will create a copy and return a pointer to it, so you can controll it\n"
"// while it is playing. The returned pointer can be discarded.\n"
"fn (s: ^Sound) start*(): ^Sound {\n"
"//~~\n"
"\tcpy := new(Sound)\n"
"\tcpy ^= s.copy()\n"
"\tcpy.play()\n"
"\n"
"\tpool = append(pool, cpy)\n"
"\n"
"\treturn cpy\n"
"}\n"
"\n"
"fn umth_sound_stop(s: Sound)\n"
"//~~fn Sound.stop\n"
"// Stops the sound, but keeps the progress. If you want to start from the\n"
"// begginning, use `audio.Sound.seekToFrame(0)`.\n"
"fn (s: ^Sound) stop*() {\n"
"//~~\n"
"\tumth_sound_stop(s^)\n"
"}\n"
"\n"
"fn umth_sound_set_volume(s: Sound, vol: real32)\n"
"//~~fn Sound.setVol\n"
"// Sets the volume as a multiplier of the base volume.\n"
"fn (s: ^Sound) setVol*(vol: real32) {\n"
"//~~\n"
"\tumth_sound_set_volume(s^, vol)\n"
"}\n"
"\n"
"fn umth_sound_set_pan(s: Sound, pan: real32)\n"
"//~~fn Sound.setPan\n"
"// Sets the pan of the sound.\n"
"fn (s: ^Sound) setPan*(pan: real32) {\n"
"//~~\n"
"\tumth_sound_set_pan(s^, pan)\n"
"}\n"
"\n"
"fn umth_sound_set_pitch(s: Sound, pitch: real32)\n"
"//~~fn Sound.setPitch\n"
"// Sets the pitch of the sound.\n"
"fn (s: ^Sound) setPitch*(pitch: real32) {\n"
"//~~\n"
"\tumth_sound_set_pitch(s^, pitch)\n"
"}\n"
"\n"
"fn umth_sound_set_looping(s: Sound, looping: bool)\n"
"//~~fn Sound.setLooping\n"
"// Sets whether the sound will loop upon finishing.\n"
"fn (s: ^Sound) setLooping*(looping: bool) {\n"
"//~~\n"
"\tumth_sound_set_looping(s^, looping)\n"
"}\n"
"\n"
"fn umth_sound_seek_to_frame(s: Sound, frame: uint)\n"
"//~~fn Sound.seekToFrame\n"
"// Seeks to a specified PCM frame.\n"
"fn (s: ^Sound) seekToFrame*(frame: uint) {\n"
"//~~\n"
"\tumth_sound_seek_to_frame(s^, frame)\n"
"}\n"
"\n"
"fn umth_sound_frame_count(s: Sound): uint\n"
"//~~fn Sound.frameCount\n"
"// Returns length of the sound in PCM frames.\n"
"fn (s: ^Sound) frameCount*(): uint {\n"
"//~~\n"
"\treturn umth_sound_frame_count(s^)\n"
"}\n"
"\n"
"fn umth_sound_set_start_time_ms(s: Sound, t: uint)\n"
"//~~fn Sound.setStartTimeMs\n"
"fn (s: ^Sound) setStartTimeMs*(t: uint) {\n"
"//~~\n"
"\tumth_sound_set_start_time_ms(s^, t)\n"
"}\n"
"\n"
"fn umth_sound_set_stop_time_ms(s: Sound, t: uint)\n"
"//~~fn Sound.setStopTimeMs\n"
"fn (s: ^Sound) setStopTimeMs*(t: uint) {\n"
"//~~\n"
"\tumth_sound_set_stop_time_ms(s^, t)\n"
"}\n"
"\n"
"// **INTERNAL**\n"
"fn __setup*() {\n"
"\tpool = []^Sound{}\n"
"}\n"
"\n"
"// **INTERNAL**\n"
"fn __cycle*() {\n"
"\tfor i:=0; i >= 0 && i < len(pool); i++ {\n"
"\t\tif !pool[i].isPlaying() {\n"
"\t\t\tpool = delete(pool, i)\n"
"\t\t\ti--\n"
"\t\t}\n"
"\t}\n"
"}\n"
"",
"//~~\n"
"// A CSV parser, which also works for similar formats. It doesn\'t support\n"
"// quotes, but you can escape characters using a backslash.\n"
"//~~\n"
"\n"
"//~~fn parse\n"
"// Parses input into a 2d string array.\n"
"fn parse*(inp: str, sep: char = \',\'): [][]str {\n"
"//~~\n"
"\tout := [][]str{}\n"
"\trow := []str{}\n"
"\tstart := 0\n"
"\tacc := \"\"\n"
"\tl := len(inp)\n"
"\tskipnext := false\n"
"\n"
"\tfor i,c in inp {\n"
"\t\tif skipnext { skipnext = false; continue }\n"
"\n"
"\t\tif c == \'\\\\\' {\n"
"\t\t\tacc += slice(inp, start, i)\n"
"\t\t\tstart = i + 1\n"
"\t\t\tskipnext = true\n"
"\t\t} else if c == \'\\r\' {\n"
"\t\t\tacc += slice(inp, start, i)\n"
"\t\t\tstart = i + 1\n"
"\t\t} else if c == \'\\n\' {\n"
"\t\t\tacc += slice(inp, start, i)\n"
"\t\t\tstart = i + 1\n"
"\n"
"\t\t\trow = append(row, acc)\n"
"\t\t\tout = append(out, row)\n"
"\n"
"\t\t\tacc = \"\"\n"
"\t\t\trow = []str{}\n"
"\n"
"\t\t} else if c == sep {\n"
"\t\t\tacc += slice(inp, start, i)\n"
"\t\t\tstart = i + 1\n"
"\n"
"\t\t\trow = append(row, acc)\n"
"\t\t\tacc = \"\"\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tif start < l {\n"
"\t\trow = append(row, acc + slice(inp, start, l))\n"
"\t}\n"
"\n"
"\tif len(row) > 0 {\n"
"\t\tout = append(out, row)\n"
"\t}\n"
"\n"
"\treturn out\n"
"}\n"
"\n"
"fn escapeStr(s: str, sep: char): str {\n"
"\to := \"\"\n"
"\n"
"\tfor i,c in s {\n"
"\t\tif c == sep || c == \'\\n\' || c == \'\\\\\' {\n"
"\t\t\to += \"\\\\\"\n"
"\t\t}\n"
"\t\to += str(c)\n"
"\t}\n"
"\n"
"\treturn o\n"
"}\n"
"\n"
"//~~fn encode\n"
"// Converts 2d array to csv string.\n"
"fn encode*(inp: [][]str, sep: char = \',\'): str {\n"
"//~~\n"
"\to := \"\"\n"
"\n"
"\tfor i in inp {\n"
"\t\tfor j in inp[i] {\n"
"\t\t\to += escapeStr(inp[i][j], sep)\n"
"\t\t\tif j < len(inp[i]) - 1 { o += sep }\n"
"\t\t}\n"
"\t\to += \"\\n\"\n"
"\t}\n"
"\n"
"\treturn o\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"rect.um\"\n"
"\t\"image.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"//~~struct Ent\n"
"// Entity is the main game object. It features drawing and collisions.\n"
"// Every entity has an image used for drawing and a rectangle used\n"
"// for collisions. It also has a transform used for transforming it\'s image\n"
"// and rectangle.\n"
"type Ent* = struct {\n"
"\t// used as a collider, used as backup when invalid image is supplied\n"
"\tr: rect.Rect\n"
"\t// used in drawing\n"
"\ti: image.Image\n"
"\t// used to transform and translate the image and rect\n"
"\tt: th.Transform\n"
"\t// used as a color of the rect and a color filter for the image\n"
"\tc: uint32\n"
"}\n"
"//~~\n"
"\n"
"//~~struct Coll\n"
"// Value returned by get coll. It contains a position where the collision\n"
"// happened and the index of the entity involved in said collision.\n"
"type Coll* = struct {\n"
"\tindex: th.uu\n"
"\tpos: th.Vf2\n"
"}\n"
"//~~\n"
"\n"
"fn umth_ent_draw(e: ^Ent, c: ^rect.Rect)\n"
"//~~fn Ent.draw\n"
"// Draws the entity onto the screen in relaction to camera c.\n"
"fn (e: ^Ent) draw*(c: rect.Rect) {\n"
"//~~\n"
"\tumth_ent_draw(e, &c)\n"
"}\n"
"\n"
"//~~fn mk\n"
"// ent\'s constructor\n"
"fn mk*(img: image.Image = image.Image{}, t: th.Transform = th.Transform{ s: th.Vf2{1, 1} }): Ent {\n"
"//~~\n"
"\tvar e: Ent\n"
"\te.i = img\n"
"\te.t = t\n"
"\tif img.validate() {\n"
"\t\tdm := img.getDims()\n"
"\t\te.r.w = dm.x\n"
"\t\te.r.h = dm.y\n"
"\t}\n"
"\te.c = th.white\n"
"\n"
"\tif t.s.x == 0 && t.s.y == 0 {\n"
"\t\tt.s = th.Vf2{ 1, 1 }\n"
"\t}\n"
"\n"
"\treturn e\n"
"}\n"
"\n"
"fn umth_ent_getcoll(coll: ^Coll, collC: ^int, maxCount: th.uu, count: int32,\n"
"\te: ^Ent, s: ^^Ent)\n"
"//~~fn Ent.getColl\n"
"// Checks collisions of e with entities in s. Checks at max maxColl collisions.\n"
"// If s contains e, the collision won\'t be returned.\n"
"fn (e: ^Ent) getColl*(s: []^Ent, maxColls: th.uu): []Coll {\n"
"//~~\n"
"\tif len(s) == 0 {\n"
"\t\treturn []Coll{}\n"
"\t}\n"
"\n"
"\tif maxColls > len(s) {\n"
"\t\tmaxColls = len(s)\n"
"\t}\n"
"\n"
"\tif maxColls == 0 {\n"
"\t\tmaxColls = 1\n"
"\t}\n"
"\n"
"\tcolls := make([]Coll, maxColls)\n"
"\tcount := 0\n"
"\tumth_ent_getcoll(&colls[0], &count, maxColls, len(s), e, &s[0])\n"
"\n"
"\treturn slice(colls, 0, count)\n"
"}\n"
"\n"
"//~~fn Ent.animate\n"
"// Animates the entity\'s image with one of the `anim` array. <b>Won\'t</b> begin on\n"
"// the first frame. If you want that, use anim.Anim.\n"
"fn (e: ^Ent) animate*(fps: int, frames: ^[]image.Image, t: int) {\n"
"//~~\n"
"\te.i = frames^[(round(real(t)/(1000/fps)) % len(frames^))]\n"
"}\n"
"\n"
"",
"import (\n"
"\t\"rect.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"//~~opaque Image\n"
"// Represents a drawable image. It is an opaque structure.\n"
"// Images support a color filter. It is applied by multiplying the color\n"
"// of each pixel with the filter.\n"
"type Image* = struct{ _: ^struct{} }\n"
"//~~\n"
"\n"
"//~~opaque RenderTarget\n"
"// An image you can render to.\n"
"type RenderTarget* = struct { _: ^struct{} }\n"
"//~~\n"
"\n"
"fn umth_image_create_render_target(ret: ^RenderTarget, width: int, height: int, filter: int)\n"
"//~~fn createRenderTarget\n"
"// Creates a render target you can draw to, like to a window.\n"
"// Filter specifies specfifies filtering for resulting image.\n"
"// Image can be retrieved via `toImage`. \n"
"fn createRenderTarget*(size: th.Vf2, filter: int): RenderTarget {\n"
"//~~\n"
"\trt := RenderTarget{}\n"
"\tumth_image_create_render_target(&rt, trunc(size.x), trunc(size.y), filter)\n"
"\treturn rt\n"
"}\n"
"\n"
"fn umth_image_render_target_begin(rt: RenderTarget)\n"
"//~~fn RenderTarget.end\n"
"// Begins the render target rendering pass.\n"
"fn (rt: ^RenderTarget) begin*() {\n"
"//~~\n"
"\tumth_image_render_target_begin(rt^)\n"
"}\n"
"\n"
"fn umth_image_render_target_end(rt: RenderTarget, wp: th.Vf2)\n"
"//~~fn RenderTarget.end\n"
"// Ends the render target rendering pass.\n"
"fn (rt: ^RenderTarget) end*(wp: th.Vf2) {\n"
"//~~\n"
"\tumth_image_render_target_end(rt^, wp)\n"
"}\n"
"\n"
"fn umth_image_render_target_to_image(ret: ^Image, rt: RenderTarget)\n"
"//~~fn RenderTarget.toImage\n"
"// Returns the image of the render target.\n"
"// Do not call `setfilter` on the resulting image. \n"
"fn (rt: ^RenderTarget) toImage*(): Image {\n"
"//~~\n"
"\timg := Image{}\n"
"\tumth_image_render_target_to_image(&img, rt^)\n"
"\treturn img\n"
"}\n"
"\n"
"fn umth_image_load(ret: ^Image, path: str)\n"
"//~~fn load\n"
"// Loads an image at path.\n"
"fn load*(path: str): Image {\n"
"//~~\n"
"\timg := Image{}\n"
"\tumth_image_load(&img, path)\n"
"\treturn img\n"
"}\n"
"\n"
"fn umth_image_flipv(i: Image, f: bool)\n"
"//~~fn Image.flipv\n"
"// Flips image on it\'s vertical axis.\n"
"fn (i: ^Image) flipv*(flip: bool) {\n"
"//~~\n"
"\tumth_image_flipv(i^, flip)\n"
"}\n"
"\n"
"fn umth_image_fliph(i: Image, f: bool)\n"
"//~~fn Image.fliph\n"
"// Flips image on it\'s horizontal axis.\n"
"fn (i: ^Image) fliph*(flip: bool) {\n"
"//~~\n"
"\tumth_image_fliph(i^, flip)\n"
"}\n"
"\n"
"fn umth_image_draw(img: Image, t: ^th.Transform, color: uint32)\n"
"//~~fn Image.draw\n"
"// Draws the image in screen coordinates. It transforms it with t and\n"
"// applies color as a color filter.\n"
"fn (i: ^Image) draw*(t: th.Transform, color: uint32 = th.white) {\n"
"//~~\n"
"\tumth_image_draw(i^, &t, color)\n"
"}\n"
"\n"
"fn umth_image_draw_nine_patch(img: Image, outer, inner, dest: ^rect.Rect,\n"
"\tcolor: uint32)\n"
"//~~fn Image.drawNinepatch\n"
"// Draws \"nine-patch\" image. \n"
"// `outer` specifies the texture coordinates of the outer rect of source image,\n"
"// `inner` specifies coordinates of inner rect of source image, positioned relative to `outer`.\n"
"// You can tint with `color`.\n"
"fn (i: ^Image) drawNinepatch*(outer, inner, dest: rect.Rect, color: uint32 = th.white) {\n"
"//~~\n"
"\tumth_image_draw_nine_patch(i^, &outer, &inner, &dest, color)\n"
"}\n"
"\n"
"fn umth_image_draw_on_quad(img: Image, color: uint32, q: th.Quad)\n"
"//~~fn Image.drawOnQuad\n"
"// Draws the image on top of a quad with corners of the image positioned\n"
"// on the verticies of the quad.\n"
"fn (i: ^Image) drawOnQuad*(q: th.Quad, color: uint32 = th.white) {\n"
"//~~\n"
"\tumth_image_draw_on_quad(i^, color, q)\n"
"}\n"
"\n"
"//~~fn Image.validate\n"
"// Returns true, if i\'s handle points to an image.\n"
"fn (i: ^Image) validate*(): bool {\n"
"//~~\n"
"\treturn i._ != null\n"
"}\n"
"\n"
"fn umth_image_get_dims(dm: ^th.Vf2, i: Image)\n"
"//~~fn Image.getDims\n"
"// Returns width and heigth.\n"
"fn (i: ^Image) getDims*(): th.Vf2 {\n"
"//~~\n"
"\tout := th.Vf2{}\n"
"\tumth_image_get_dims(&out, i^)\n"
"\n"
"\treturn out\n"
"}\n"
"\n"
"fn umth_image_crop(img: Image, tl, br: th.Vf2)\n"
"//~~fn Image.crop\n"
"// Crops an image. Coordinates are between 0, 0 (top left) and\n"
"// 1, 1 (bottom right)\n"
"fn (i: ^Image) crop*(tl, br: th.Vf2) {\n"
"//~~\n"
"\tumth_image_crop(i^, tl, br)\n"
"}\n"
"\n"
"fn umth_image_crop_quad(img: Image, q: ^th.Quad)\n"
"//~~fn Image.cropQuad\n"
"// Crop an image using a quad.\n"
"fn (i: ^Image) cropQuad*(q: th.Quad) {\n"
"//~~\n"
"\tumth_image_crop_quad(i^, &q)\n"
"}\n"
"\n"
"fn umth_image_get_crop_quad(img: Image, q: ^th.Quad)\n"
"//~~fn Image.getCropQuad\n"
"// Crop an image using a quad.\n"
"fn (i: ^Image) getCropQuad*(): th.Quad {\n"
"//~~\n"
"\tvar (q: th.Quad)\n"
"\tumth_image_get_crop_quad(i^, &q)\n"
"\treturn q\n"
"}\n"
"\n"
"fn umth_image_from_data(ret: ^Image, data: ^uint32, dm: th.Vf2)\n"
"//~~fn mk\n"
"// Creates an image from raw data.\n"
"fn mk*(data: []uint32, dm: th.Vf2): Image {\n"
"//~~\n"
"\timg := Image{}\n"
"\tumth_image_from_data(&img, &data[0], dm)\n"
"\n"
"\treturn img\n"
"}\n"
"\n"
"fn umth_image_copy(ret: ^Image, data: Image)\n"
"//~~fn Image.copy\n"
"// Copies image into a new one.\n"
"fn (i: ^Image) copy*(): Image {\n"
"//~~\n"
"\timg := Image{}\n"
"\tumth_image_copy(&img, i^)\n"
"\t\n"
"\treturn img\n"
"}\n"
"\n"
"fn umth_image_set_filter(data: Image, filter: int)\n"
"//~~fn Image.setfilter\n"
"// Sets a mag/min filter. 0 is nearest, others are linear.\n"
"// This function will regenerate the texture. This means it shouldn\'t be\n"
"// used in a loop.\n"
"// https://learnopengl.com/img/getting-started/texture_filtering.png\n"
"// left is nearest, right is linear.\n"
"fn (i: ^Image) setfilter*(filter: int) {\n"
"//~~\n"
"\tumth_image_set_filter(i^, filter)\n"
"}\n"
"\n"
"fn umth_image_update_data(img: Image, data: ^uint32, dm: th.Vf2)\n"
"//~~fn Image.setData\n"
"// Updates the image data. dm are the dimensions of the new image.\n"
"// The new image doesn\'t have to be the same size as the old one.\n"
"fn (i: ^Image) setData*(data: []uint32, dm: th.Vf2) {\n"
"//~~\n"
"\tif dm.x * dm.y != len(data) {\n"
"\t\terror(\"setData: incorrect dimensions: \" + repr(dm.x * dm.y) + \"!= \" + repr(len(data)))\n"
"\t}\n"
"\n"
"\tif len(data) == 0 {\n"
"\t\terror(\"setData: can\'t set empty image\")\n"
"\t}\n"
"\n"
"\tumth_image_update_data(i^, &data[0], dm)\n"
"}\n"
"\n"
"fn umth_image_get_data(img: Image, data: ^uint32)\n"
"//~~fn Image.getData\n"
"// Gets the image data. This downloads the data from the GPU on **each call**.\n"
"// Don\'t use in performance critical sections.\n"
"fn (i: ^Image) getData*(): []uint32 {\n"
"//~~\n"
"\tif i._ == null {\n"
"\t\treturn []uint32{}\n"
"\t}\n"
"\n"
"\tbuf := make([]uint32, trunc(i.getDims().x * i.getDims().y))\n"
"\tif len(buf) == 0 {\n"
"\t\treturn buf\n"
"\t}\n"
"\n"
"\tumth_image_get_data(i^, &buf[0])\n"
"\n"
"\treturn buf\n"
"}\n"
"",
"//~~\n"
"// Module for getting keyboard and mouse input.\n"
"// is* functions return info based on a us QWERTY layout. They are supposed to\n"
"// be used for game controls. For text input use getStr.\n"
"//~~\n"
"\n"
"import (\n"
"    \"th.um\"\n"
"    \"rect.um\"\n"
")\n"
"\n"
"//~~Keycode constants\n"
"const (\n"
"    mouse1*              = 1   // NOTE: mouse 2 and 3 key codes are swapped\n"
"    mouse2*              = 3   //       because sokol uses 3 for middle mouse\n"
"    mouse3*              = 2   //       button.\n"
"\n"
"    key_ctrl*            = 16\n"
"    key_shift*           = 17\n"
"    key_alt*             = 18\n"
"\n"
"    key_space*           = 32\n"
"    key_apostrophe*      = 39  /* \' */\n"
"    key_comma*           = 44  /* , */\n"
"    key_minus*           = 45  /* - */\n"
"    key_dot*             = 46  /* . */\n"
"    key_slash*           = 47  /* / */\n"
"    key_0*               = 48\n"
"    key_1*               = 49\n"
"    key_2*               = 50\n"
"    key_3*               = 51\n"
"    key_4*               = 52\n"
"    key_5*               = 53\n"
"    key_6*               = 54\n"
"    key_7*               = 55\n"
"    key_8*               = 56\n"
"    key_9*               = 57\n"
"    key_semicolon*       = 59  /* ; */\n"
"    key_equal*           = 61  /* = */\n"
"    key_a*               = 65\n"
"    key_b*               = 66\n"
"    key_c*               = 67\n"
"    key_d*               = 68\n"
"    key_e*               = 69\n"
"    key_f*               = 70\n"
"    key_g*               = 71\n"
"    key_h*               = 72\n"
"    key_i*               = 73\n"
"    key_j*               = 74\n"
"    key_k*               = 75\n"
"    key_l*               = 76\n"
"    key_m*               = 77\n"
"    key_n*               = 78\n"
"    key_o*               = 79\n"
"    key_p*               = 80\n"
"    key_q*               = 81\n"
"    key_r*               = 82\n"
"    key_s*               = 83\n"
"    key_t*               = 84\n"
"    key_u*               = 85\n"
"    key_v*               = 86\n"
"    key_w*               = 87\n"
"    key_x*               = 88\n"
"    key_y*               = 89\n"
"    key_z*               = 90\n"
"    key_left_bracket*    = 91  /* [ */\n"
"    key_backslash*       = 92  /* \\ */\n"
"    key_right_bracket*   = 93  /* ] */\n"
"    key_grave_accent*    = 96  /* ` */\n"
"    key_world_1*         = 161 /* non-US #1 */\n"
"    key_world_2*         = 162 /* non-US #2 */\n"
"    key_escape*          = 256\n"
"    key_enter*           = 257\n"
"    key_tab*             = 258\n"
"    key_backspace*       = 259\n"
"    key_insert*          = 260\n"
"    key_delete*          = 261\n"
"    key_right*           = 262\n"
"    key_left*            = 263\n"
"    key_down*            = 264\n"
"    key_up*              = 265\n"
"    key_page_up*         = 266\n"
"    key_page_down*       = 267\n"
"    key_home*            = 268\n"
"    key_end*             = 269\n"
"    key_caps_lock*       = 280\n"
"    key_scroll_lock*     = 281\n"
"    key_num_lock*        = 282\n"
"    key_print_screen*    = 283\n"
"    key_pause*           = 284\n"
"\tkey_fn*              = 289\n"
"    key_fn1*             = 290\n"
"    key_fn2*             = 291\n"
"    key_fn3*             = 292\n"
"    key_fn4*             = 293\n"
"    key_fn5*             = 294\n"
"    key_fn6*             = 295\n"
"    key_fn7*             = 296\n"
"    key_fn8*             = 297\n"
"    key_fn9*             = 298\n"
"    key_fn10*            = 299\n"
"    key_fn11*            = 300\n"
"    key_fn12*            = 301\n"
"    key_fn13*            = 302\n"
"    key_fn14*            = 303\n"
"    key_fn15*            = 304\n"
"    key_fn16*            = 305\n"
"    key_fn17*            = 306\n"
"    key_fn18*            = 307\n"
"    key_fn19*            = 308\n"
"    key_fn20*            = 309\n"
"    key_fn21*            = 310\n"
"    key_fn22*            = 311\n"
"    key_fn23*            = 312\n"
"    key_fn24*            = 313\n"
"    key_fn25*            = 314\n"
"    key_kp_0*            = 320\n"
"    key_kp_1*            = 321\n"
"    key_kp_2*            = 322\n"
"    key_kp_3*            = 323\n"
"    key_kp_4*            = 324\n"
"    key_kp_5*            = 325\n"
"    key_kp_6*            = 326\n"
"    key_kp_7*            = 327\n"
"    key_kp_8*            = 328\n"
"    key_kp_9*            = 329\n"
"    key_kp_decimal*      = 330\n"
"    key_kp_divide*       = 331\n"
"    key_kp_multiply*     = 332\n"
"    key_kp_subtract*     = 333\n"
"    key_kp_add*          = 334\n"
"    key_kp_enter*        = 335\n"
"    key_kp_equal*        = 336\n"
"    key_left_shift*      = 340\n"
"    key_left_control*    = 341\n"
"    key_left_alt*        = 342\n"
"    key_left_super*      = 343\n"
"    key_right_shift*     = 344\n"
"    key_right_control*   = 345\n"
"    key_right_alt*       = 346\n"
"    key_right_super*     = 347\n"
"    key_menu*            = 348\n"
")\n"
"//~~\n"
"\n"
"\n"
"fn toupper(c: char): int {\n"
"    if c >= \'a\' && c <= \'z\' {\n"
"        return int(c) - 32;\n"
"    }\n"
"    return int(c);\n"
"}\n"
"\n"
"fn umth_input_get_mouse(out: ^th.Vf2)\n"
"//~~fn getMousePos\n"
"// Returns the position of mouse cursor in relation to the screen.\n"
"fn getMousePos*(): th.Vf2 {\n"
"//~~\n"
"\tout := th.Vf2{}\n"
"\tumth_input_get_mouse(&out)\n"
"\treturn out\n"
"}\n"
"\n"
"//~~fn getGlobalMousePos\n"
"// Returns the position of mouse cursor in relation to cam.\n"
"fn getGlobalMousePos*(cam: rect.Rect): th.Vf2 {\n"
"//~~\n"
"\treturn cam.toWorld(getMousePos())\n"
"}\n"
"\n"
"fn umth_input_is_pressed(keycode: int): int32\n"
"//~~fn isPressed\n"
"// Returns true if key is pressed. Either use codes defined in the file above,\n"
"// or pass lower case char/number.\n"
"fn isPressed*(code: int): bool {\n"
"//~~\n"
"\tval := bool(umth_input_is_pressed(code))\n"
"\treturn val\n"
"}\n"
"\n"
"//~~fn isPressedc\n"
"// Like `isPressed`, but you can pass char as the code.\n"
"fn isPressedc*(code: char): bool {\n"
"//~~\n"
"\treturn isPressed(toupper(code))\n"
"}\n"
"\n"
"fn umth_input_is_just_pressed(key: int): int32\n"
"//~~fn isJustPressed\n"
"// Returns, whether code was just pressed this loop.\n"
"fn isJustPressed*(code: int): bool {\n"
"//~~\n"
"\treturn bool(umth_input_is_just_pressed(code))\n"
"}\n"
"\n"
"//~~fn isJustPressedc\n"
"// Like `isJustPressed`, but you can pass char as the code.\n"
"fn isJustPressedc*(code: char): bool {\n"
"//~~\n"
"\treturn isJustPressed(toupper(code))\n"
"}\n"
"\n"
"fn umth_input_is_pressed_repeat(key: int): int32\n"
"//~~fn isPressedRepeat\n"
"// Returns, whether code was just pressed this loop, with key repeat.\n"
"fn isPressedRepeat*(code: int): bool {\n"
"//~~\n"
"    return bool(umth_input_is_pressed_repeat(code))\n"
"}\n"
"\n"
"//~~fn isPressedRepeatc\n"
"// Like `isPressedRepeat`, but you can pass char as the code.\n"
"fn isPressedRepeatc*(code: char): bool {\n"
"//~~\n"
"    return isPressedRepeat(toupper(code))\n"
"}\n"
"\n"
"\n"
"fn umth_input_is_just_released(key: int): int32\n"
"//~~fn isJustReleased\n"
"// Returns true if a key was just released.\n"
"fn isJustReleased*(code: int): bool {\n"
"//~~\n"
"\treturn bool(umth_input_is_just_released(code))\n"
"}\n"
"//~~fn isJustReleasedc\n"
"// Like `isJustReleased`, but you can pass char as the code.\n"
"fn isJustReleasedc*(code: char): bool {\n"
"//~~\n"
"\treturn isJustReleased(toupper(code))\n"
"}\n"
"\n"
"fn umth_input_clear*(code: int)\n"
"//~~fn clear\n"
"// Clears both the pressed and justPressed state of a code.\n"
"fn clear*(code: int) {\n"
"//~~\n"
"\tumth_input_clear(code)\n"
"}\n"
"\n"
"//~~fn clearc\n"
"// Like `clear`, but you can pass char as the code.\n"
"fn clearc*(code: char) {\n"
"//~~\n"
"    umth_input_clear(toupper(code))\n"
"}\n"
"\n"
"fn umth_input_get_str(): str\n"
"//~~fn getStr\n"
"// Returns a string entered by the user in the last cycle.\n"
"fn getStr*(): str {\n"
"//~~\n"
"\treturn umth_input_get_str()\n"
"}\n"
"\n"
"fn umth_input_get_mouse_delta(o: ^th.Vf2)\n"
"//~~fn getMouseDelta\n"
"// Returns the difference between mouse positions in the last cycle. Will work\n"
"// even if `window.freezeCursor` is enabled.\n"
"fn getMouseDelta*(): th.Vf2 {\n"
"//~~\n"
"\to := th.Vf2{}\n"
"\tumth_input_get_mouse_delta(&o)\n"
"\treturn o\n"
"}\n"
"\n"
"fn umth_input_get_mouse_scroll(x, y: ^th.fu)\n"
"//~~fn getMouseScroll\n"
"// Returns the scroll wheel value\n"
"fn getMouseScroll*(): th.Vf2 {\n"
"//~~\n"
"    var x, y: th.fu\n"
"    umth_input_get_mouse_scroll(&x, &y)\n"
"    return th.Vf2{x, y}\n"
"}",
"//~~\n"
"// Misc functions.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"std.um\"\t\t\t\t\t\t\t\n"
")\n"
"\n"
"//~~fn readall\n"
"// Reads file content into a string.\n"
"fn readall*(path: str): str {\n"
"//~~\n"
"\tf := std.fopen(path, \"r\")\n"
"\tconst blockSize = 16\n"
"\tres := \"\"\n"
"\n"
"\tfor ok := true; ok {\n"
"\t  var buff: [blockSize + 1]char\n"
"\t  ok = std.fread(f, ^[blockSize]char(&buff)) == 1\n"
"\t  res += str([]char(buff))\n"
"\t}\n"
"\n"
"\tstd.fclose(f)\n"
"\treturn res\n"
"}\n"
"\n"
"//~~fn stepify\n"
"// Snaps a value to step.\n"
"fn stepify*(val, step: th.fu): th.fu {\n"
"//~~\n"
"\tif step != 0 {\n"
"\t\tval = floor(val / step + 0.5) * step\n"
"\t}\n"
"\treturn val\n"
"}\n"
"",
"//~~\n"
"// Canvas library allowing for drawing basic shapes. Coordinates are based on\n"
"// the screen.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"fn umth_canvas_draw_text(text: str, pos: th.Vf2, color: uint32, size: th.fu)\n"
"//~~fn drawText\n"
"// Draws a basic pixel text. Only ascii is supported.\n"
"fn drawText*(text: str, pos: th.Vf2, color: uint32, size: th.fu) {\n"
"//~~\n"
"\tumth_canvas_draw_text(text, pos, color, size)\n"
"}\n"
"\n"
"//~~fn textSize\n"
"// Returns the size of text taken by an equivalent drawText call.\n"
"fn textSize*(text: str, scale: th.fu): th.Vf2 {\n"
"//~~\n"
"\tvar w, maxw, h: int\n"
"\tw = 0\n"
"\tmaxw = 0\n"
"\th = 1\n"
"\t\n"
"\tfor i in text {\n"
"\t\tif text[i] == \"\\n\" {\n"
"\t\t\th += 1\n"
"\t\t\tif w > maxw {\n"
"\t\t\t\tmaxw = w\n"
"\t\t\t}\n"
"\n"
"\t\t\tcontinue\n"
"\t\t}\n"
"\n"
"\t\tw++\n"
"\t}\n"
"\n"
"\tif w > maxw {\n"
"\t\tmaxw = w\n"
"\t}\n"
"\n"
"\treturn th.Vf2{maxw * scale * 6 - scale, h * 6 * scale}\n"
"}\n"
"\n"
"fn umth_canvas_draw_rect(color: uint32, r: rect.Rect)\n"
"//~~fn drawRect\n"
"// Draws a Rectangle.\n"
"fn drawRect*(color: uint32, r: rect.Rect) {\n"
"//~~\n"
"\tumth_canvas_draw_rect(color, r)\n"
"}\n"
"\n"
"fn umth_canvas_draw_line(color: uint32, b, e: th.Vf2, thickness: th.fu)\n"
"//~~fn drawLine\n"
"// Draws a line.\n"
"fn drawLine*(color: uint32, b, e: th.Vf2, thickness: th.fu) {\n"
"//~~\n"
"\tumth_canvas_draw_line(color, b, e, thickness)\n"
"}\n"
"\n"
"fn umth_canvas_draw_quad(color: uint32, q: ^th.Quad)\n"
"//~~fn drawQuad\n"
"// Draws a convex quad.\n"
"fn drawQuad*(color: uint32, q: th.Quad) {\n"
"//~~\n"
"\tumth_canvas_draw_quad(color, &q)\n"
"}\n"
"\n"
"fn umth_canvas_begin_scissor_rect(x, y, w, h: real)\n"
"fn umth_canvas_end_scissor()\n"
"//~~fn beginScissorRect\n"
"// Disable rendering outside of rect `r`\n"
"fn beginScissorRect*(r: rect.Rect) {\n"
"//~~\n"
"\tumth_canvas_begin_scissor_rect(r.x, r.y, r.w, r.h)\n"
"}\n"
"\n"
"//~~fn endScissor\n"
"// Stops cropping\n"
"fn endScissor*() {\n"
"//~~\n"
"\tumth_canvas_end_scissor();\n"
"}",
"// This module will undergo changes.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"ent.um\"\n"
"\t\"rect.um\"\n"
"\t\"canvas.um\"\n"
"\t\"tilemap.um\"\n"
")\n"
"\n"
"// Ray type.\n"
"type Ray* = struct {\n"
"\tpos: th.Vf2\n"
"\tl: th.fu // length\n"
"\tr: th.fu // rotation\n"
"}\n"
"\n"
"// Makes a ray.\n"
"fn mk*(pos: th.Vf2, l: th.fu, r: th.fu = 0.0): Ray {\n"
"\treturn Ray{pos, l, r}\n"
"}\n"
"\n"
"fn umth_ray_getcoll(colls: ^ent.Coll, count: ^int, maxCount,\n"
"\tsceneLen: int, r: ^Ray, scene: ^^ent.Ent)\n"
"// Same as ent.getcoll. Same changes will apply.\n"
"fn (r: ^Ray) getColl*(s: []^ent.Ent, maxColls: th.uu): []ent.Coll {\n"
"\tif len(s) == 0 {\n"
"\t\treturn []ent.Coll{}\n"
"\t}\n"
"\n"
"\tif maxColls > len(s) {\n"
"\t\tmaxColls = len(s)\n"
"\t}\n"
"\n"
"\tcolls := make([]ent.Coll, maxColls)\n"
"\tcount := 0\n"
"\tumth_ray_getcoll(&colls[0], &count, maxColls, len(s), r, &s[0])\n"
"\treturn slice(colls, 0, count)\n"
"}\n"
"\n"
"fn umth_ray_get_tilemap_coll(r: ^Ray, t: ^tilemap.Tilemap, ic: ^th.Vf2): bool\n"
"// Gets ray\'s collision to a tilemap.\n"
"fn (r: ^Ray) getTilemapColl*(t: tilemap.Tilemap, ic: ^th.Vf2): bool {\n"
"\treturn umth_ray_get_tilemap_coll(r, &t, ic)\n"
"}\n"
"\n"
"fn (r: ^Ray) draw*(cam: rect.Rect, color: uint32, thickness: th.fu) {\n"
"\tp1 := cam.toScreen(r.pos)\n"
"\tp2 := cam.toScreen(r.pos.add(th.Vf2{0, r.l}.rotated(th.Vf2{}, r.r)))\n"
"\tcanvas.drawLine(color, p1, p2, thickness)\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\t\n"
")\n"
"\n"
"//~~struct Rect\n"
"// A set of points representing a rectangle.\n"
"type Rect* = struct {\n"
"\tx, y, w, h: th.fu\n"
"}\n"
"//~~\n"
"\n"
"//~~fn mk\n"
"fn mk*(x, y, w, h: th.fu): Rect {\n"
"//~~\n"
"\tvar r: Rect\n"
"\n"
"\tr.x = x\n"
"\tr.y = y\n"
"\tr.w = w\n"
"\tr.h = h\n"
"\n"
"\treturn r\n"
"}\n"
"\n"
"//~~fn Rect.toWorld\n"
"// translates screen coordinates to world coordinates with cam r\n"
"fn (r: ^Rect) toWorld*(p: th.Vf2): th.Vf2 {\n"
"//~~\n"
"\treturn th.Vf2{ p.x + r.x, p.y + r.y }\n"
"}\n"
"\n"
"//~~fn Rect.toScreen\n"
"// translates world coordinates to screen coordinates with cam r\n"
"fn (r: ^Rect) toScreen*(p: th.Vf2): th.Vf2 {\n"
"//~~\n"
"\treturn th.Vf2{ p.x - r.x, p.y - r.y }\n"
"}\n"
"\n"
"//~~fn Rect.getPos\n"
"fn (r: ^Rect) getPos*(): th.Vf2 {\n"
"//~~\n"
"\treturn th.Vf2{r.x, r.y}\n"
"}\n"
"\n"
"//~~fn Rect.getDims\n"
"fn (r: ^Rect) getDims*(): th.Vf2 {\n"
"//~~\n"
"\treturn th.Vf2{r.w, r.h}\n"
"}\n"
"\n"
"//~~fn Rect.getEnd\n"
"// returns where the second point of the rectangle lies.\n"
"fn (r: ^Rect) getEnd*(): th.Vf2 {\n"
"//~~\n"
"\treturn th.Vf2{r.x+r.w, r.y+r.h}\n"
"}\n"
"\n"
"fn umth_transform_rect(ret: ^th.Quad, r: ^Rect, t: ^th.Transform)\n"
"//~~fn Rect.transformed\n"
"// Transforms a rect into a quad.\n"
"// Order:\n"
"// \t1. scale\n"
"// \t2. rotation\n"
"// \t3. position\n"
"fn (r: ^Rect) transformed*(t: th.Transform): th.Quad {\n"
"//~~\n"
"\tvar ret: th.Quad\n"
"\tumth_transform_rect(&ret, r, &t)\n"
"\n"
"\treturn ret\n"
"}\n"
"\n"
"//~~fn Rect.shrink\n"
"// Shrink the rectangle by `p` pixels from all sides.\n"
"fn (r: ^Rect) shrink*(p: th.Vf2): Rect {\n"
"//~~\n"
"\treturn Rect{ r.x + p.x, r.y + p.y, r.w - 2*p.x, r.h - 2*p.y }\n"
"}\n"
"\n"
"//~~fn Rect.shift\n"
"// Shift the rectangle by `p` pixels.\n"
"fn (r: ^Rect) shift*(p: th.Vf2): Rect {\n"
"//~~\n"
"\treturn Rect{ r.x + p.x, r.y + p.y, r.w, r.h }\n"
"}\n"
"\n"
"//~~fn Rect.scale\n"
"// Multiply the dimensions by `p`\n"
"fn (r: ^Rect) scale*(p: th.Vf2): Rect {\n"
"//~~\n"
"\treturn Rect{ r.x, r.y, r.w * p.x, r.h * p.y }\n"
"}\n"
"",
"//~~\n"
"// Tilemaps allow for easy level construction and fast collisions. You can even\n"
"// use them for some games instead of entities (tetris comes to mind)\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
"\t\"ent.um\"\n"
"\t\"atlas.um\"\n"
")\n"
"\n"
"//~~Direction constants used for autotile\n"
"const (\n"
"\ttop* = 1\n"
"\tright* = 2\n"
"\tbot* = 4\n"
"\tleft* = 8\n"
")\n"
"//~~\n"
"\n"
"//~~struct Tilemap\n"
"// Tilemap struct\n"
"type Tilemap* = struct {\n"
"\tatlas: atlas.Atlas\n"
"\tpos: th.Vf2\n"
"\tw: th.uu // width of tilemap\n"
"\tcells: []th.uu // all cells (this will draw the tile in tiles with number in cells - 1)\n"
"\tcollMask: []bool // if true, the tile collides\n"
"\tscale: th.fu\n"
"}\n"
"//~~\n"
"\n"
"//~~fn mk\n"
"fn mk*(cells: []th.uu, w: th.uu, at: atlas.Atlas, scale: th.fu = 1): Tilemap {\n"
"//~~\n"
"\tt := Tilemap{}\n"
"\tt.cells = cells\n"
"\tt.w = w\n"
"\tt.atlas = at\n"
"\tt.collMask = make([]bool, 10) //  TODO\n"
"\tt.scale = scale\n"
"\t\n"
"\treturn t\n"
"}\n"
"\n"
"//~~fn Tilemap.edit\n"
"// Sets tile at [x, y] to tile.\n"
"fn (t: ^Tilemap) edit*(x, y, tile: int) {\n"
"//~~\n"
"\tt.cells[y*t.w + x] = tile\n"
"}\n"
"\n"
"fn umth_tilemap_draw(ct: ^Tilemap, cam: ^rect.Rect)\n"
"//~~fn Tilemap.draw\n"
"// Draws the tilemap.\n"
"fn (t: ^Tilemap) draw*(cam: rect.Rect) {\n"
"//~~\n"
"\tif len(t.cells) == 0 { return }\n"
"\n"
"\tumth_tilemap_draw(t, &cam)\n"
"}\n"
"\n"
"fn umth_tilemap_getcoll(pos: ^th.Vf2, vert: ^th.uu, t: ^Tilemap, e: ^ent.Ent): int32\n"
"//~~fn Tilemap.getColl\n"
"// Checks, if t collides with e.\n"
"// pos is the tile index where the collision happened\n"
"// vert is which index collided\n"
"// You need to pass a valid pointer (TODO)\n"
"fn (t: ^Tilemap) getColl*(e: ent.Ent, vert: ^th.uu, pos: ^th.Vf2): bool {\n"
"//~~\n"
"\tif len(t.cells) == 0 { return false }\n"
"\n"
"\tc := umth_tilemap_getcoll(pos, vert, t, &e)\n"
"\n"
"\treturn bool(c)\n"
"}\n"
"\n"
"fn umth_tilemap_autotile(tgt: ^th.uu, w, h: th.uu, src, cfg: ^th.uu, tile: th.uu)\n"
"//~~fn Tilemap.autotile\n"
"// Autotile turns all `tile` tiles in `src` into tiles in `tileCfg`, so they\n"
"// follow up correctly. `tileCfg` is an array of 16 tiles. They are placed in\n"
"// a way where OR of all the places where the tile continues (top, right bot,\n"
"// right). The constants for them are defined in this file. Example:\n"
"// tileCfg[top | bot] = 21\n"
"// top | bot would look something like this: |\n"
"fn (t: ^Tilemap) autotile*(src, tileCfg: []th.uu, tile: th.uu) {\n"
"//~~\n"
"\tif len(tileCfg) < 16 {\n"
"\t\terror(\"autotile: tileCfg len isn\'t 16\'\")\n"
"\t}\n"
"\n"
"\tumth_tilemap_autotile(&t.cells[0], t.w, len(t.cells)/t.w, &src[0], &tileCfg[0], tile)\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"audio.um\"\n"
"\t\"canvas.um\"\n"
"\t\"image.um\"\n"
"\t\"placeholders.um\"\n"
"\t\"rect.um\"\n"
"\t\"signal.um\"\n"
"\t\"std.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"var (\n"
"\tstart, clockOffset: real\n"
"\tfpsLimit: int = 60\n"
")\n"
"\n"
"//~~Window dimensions\n"
"var (\n"
"\tw*, h*: int32\n"
")\n"
"//~~\n"
"\n"
"//~~Viewport size\n"
"var wp*: th.Vf2\n"
"//~~\n"
"\n"
"//~~signal OnFrame\n"
"var onFrame*: signal.Signal\n"
"//~~\n"
"\n"
"fn umth_window_setup(title: str, w, h: int)\n"
"fn umth_window_get_dimensions(w, h: ^int32)\n"
"\n"
"fn umth_window_set_viewport(dm: th.Vf2)\n"
"//~~fn setViewport\n"
"// Sets the dimensions of the viewport. The dimensions are saved in the `wp`\n"
"// variable.\n"
"// \n"
"// `dm`\n"
"// : dimension of the viewport\n"
"fn setViewport*(dm: th.Vf2) {\n"
"//~~\n"
"\twp = dm\n"
"\tumth_window_set_viewport(dm)\n"
"}\n"
"\n"
"fn setIcon*(img: image.Image)\n"
"\n"
"// 0 = other/unknown\n"
"// 2 = linux\n"
"// 3 = windows\n"
"// 4 = macos (unsupported currently)\n"
"// 5 = emscripten\n"
"fn umth_window_get_platform_id(): int\n"
"\n"
"//~~fn setup\n"
"// Sets up the engine and opens a window.\n"
"fn setup*(title: str = \"tophat game\", width: int = 400, height: int32 = 400) {\n"
"//~~\n"
"\tw, h = width, height\n"
"\tumth_window_setup(title, width, height)\n"
"\n"
"\tth.platform = umth_window_get_platform_id()\n"
"\n"
"\taudio.__setup()\n"
"\tplaceholders.__setup()\n"
"\n"
"\tsetIcon(placeholders.icon)\n"
"\n"
"\tclockOffset = std.clock() * 1000\n"
"\tstart = std.clock() * 1000\n"
"\n"
"\tsetViewport(th.Vf2{width, height})\n"
"}\n"
"\n"
"//~~fn cycle\n"
"// Cycle needs to be called every cycle for the window to work. If the window\n"
"// was closed, it returns false.\n"
"fn cycle(delta: real) {\n"
"//~~\n"
"\tumth_window_set_viewport(wp)\n"
"\n"
"\tth.delta = trunc(delta*1000.0)\n"
"\tif th.delta == 0 {\n"
"\t\tth.delta = 1\n"
"\t}\n"
"\n"
"\tstart = std.clock()*1000\n"
"\tth.time = round(start - clockOffset)\n"
"\n"
"\tumth_window_get_dimensions(&w, &h)\n"
"\n"
"\taudio.__cycle()\n"
"\tcanvas.drawRect(th.white, rect.mk(0, 0, wp.x, wp.y))\n"
"}\n"
"\n"
"fn drawClear() {\n"
"\tcanvas.drawRect(th.black, rect.mk(-4 * wp.x, 0, 4 * wp.x, wp.y))\n"
"\tcanvas.drawRect(th.black, rect.mk(0, -4 * wp.y, wp.x, 4 * wp.y))\n"
"\tcanvas.drawRect(th.black, rect.mk(wp.x, 0, 4 * wp.x, wp.y))\n"
"\tcanvas.drawRect(th.black, rect.mk(0, wp.y, wp.x, 4 * wp.y))\n"
"}\n"
"\n"
"fn umth_frame_callback*(delta: real) {\n"
"\tcycle(delta)\n"
"\tonFrame.emit(null)\n"
"\tdrawClear()\n"
"}\n"
"\n"
"fn umth_window_set_fullscreen(fullscreen: bool)\n"
"fn umth_window_get_fullscreen(): bool\n"
"\n"
"//~~fn setFullscreen\n"
"// Makes window go full screen\n"
"fn setFullscreen*(fullscreen: bool) {\n"
"//~~\n"
"\tumth_window_set_fullscreen(fullscreen)\n"
"}\n"
"\n"
"//~~fn isFullscreen\n"
"// Returns true if window is fullscreen \n"
"fn isFullscreen*(): bool {\n"
"//~~\n"
"\treturn umth_window_get_fullscreen()\n"
"}\n"
"\n"
"//~~fn getDims\n"
"// Returns dimensions of the window in screen pixels.\n"
"fn getDims*(): th.Vf2 {\n"
"//~~\n"
"\treturn th.Vf2{w, h}\n"
"}\n"
"\n"
"fn umth_window_set_target_fps(fps: int)\n"
"\n"
"//~~fn setTargetFps\n"
"// Sets the fps limit.\n"
"// \n"
"// `fps`\n"
"// : amount of fps the limit should be set to\n"
"//\t \n"
"fn setTargetFps*(fps: int) {\n"
"//~~\n"
"\tfpsLimit = fps\n"
"\tumth_window_set_target_fps(fps)\n"
"}\n"
"\n"
"fn umth_window_set_dims(dm: th.Vf2)\n"
"//~~fn setDims\n"
"// Sets the dimensions of the window.\n"
"// \n"
"// `dm`\n"
"// : the target dimensions in screen pixels\n"
"fn setDims*(dm: th.Vf2) {\n"
"//~~\n"
"\tumth_window_set_dims(dm)\n"
"}\n"
"\n"
"fn umth_window_set_icon(img: image.Image)\n"
"//~~fn setIcon\n"
"// Sets the window icon.\n"
"fn setIcon*(img: image.Image) {\n"
"//~~\n"
"\tumth_window_set_icon(img)\n"
"}\n"
"\n"
"fn umth_window_show_cursor(show: bool)\n"
"//~~fn showCursor\n"
"// Show or hide the cursor, linux only.\n"
"fn showCursor*(show: bool) {\n"
"//~~\n"
"\tumth_window_show_cursor(show)\n"
"}\n"
"\n"
"fn umth_window_freeze_cursor(freeze: bool)\n"
"//~~fn freezeCursor\n"
"// Freezes the cursor in place. `input.getMouseDelta` will still report mouse\n"
"// movements.  The cursor will be automatically hidden.\n"
"fn freezeCursor*(freeze: bool) {\n"
"//~~\n"
"\tshowCursor(freeze)\n"
"\tumth_window_freeze_cursor(freeze)\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"utf8.um\"\n"
"\t\"rect.um\"\n"
"\t\"input.um\"\n"
"\t\"canvas.um\"\n"
")\n"
"\n"
"const (\n"
"\teventUnknown* = 0\n"
"\teventHover*\n"
"\teventPress*\n"
"\teventJustPress*\n"
"\teventRelease*\n"
")\n"
"\n"
"type Theme* = struct {\n"
"\tfg, bg: uint32\n"
"\n"
"\tborderColor: uint32\n"
"\tborderSize: th.fu\n"
"}\n"
"\n"
"// A structure all elements have to contain. t can be set manually by the user,\n"
"// s being the dimensions, or it can be set by another elements. onEvent is an\n"
"// event callback. It will pass whatever is set in the ctx field.\n"
"// Event types:\n"
"// eventUnknown\n"
"// eventHover\n"
"// eventPress\n"
"// eventJustPress\n"
"// eventRelease\n"
"type Generic* = struct {\n"
"\tr: rect.Rect\n"
"\tgridPos: th.Vf2\n"
"\tgridSpan: th.Vf2\n"
"\ttheme: Theme\n"
"\n"
"\tctx: interface{}\n"
"\tonEvent: fn(eventType: th.uu, ctx: interface{})\n"
"\tpressed: bool\n"
"\tselected: bool\n"
"}\n"
"\n"
"// An interface every ui element has to implements.\n"
"type Element* = interface {\n"
"\thandle()\n"
"\tdraw()\n"
"\tget(): ^Generic\n"
"}\n"
"\n"
"// Interface used anywhere, where text is rendered.\n"
"type TextRenderer* = interface {\n"
"\tdraw(text: str, pos: th.Vf2, color: uint32, scale: th.fu = 1.0)\n"
"\tmeasure(text: str): th.Vf2\n"
"}\n"
"\n"
"// Bindings around canvas\'s font rendering functions to make them usable\n"
"// with the TextRenderer interface.\n"
"type PixelFont* = struct { }\n"
"fn (pf: ^PixelFont) draw*(text: str, pos: th.Vf2, color: uint32, scale: th.fu = 1.0) {\n"
"\tcanvas.drawText(text, pos, color, scale)\n"
"}\n"
"fn (pf: ^PixelFont) measure*(text: str): th.Vf2 {\n"
"\treturn canvas.textSize(text, 1)\n"
"}\n"
"\n"
"fn mkGeneric*(): Generic {\n"
"\tg := Generic{}\n"
"\tg.onEvent = fn(eventType: th.uu, ctx: interface{}) { }\n"
"\treturn g\n"
"}\n"
"\n"
"// Functions that sets the grid pos of a Generic\n"
"fn (g: ^Generic) grid*(x, y: th.uu): ^Generic {\n"
"\tg.gridPos.x = x\n"
"\tg.gridPos.y = y\n"
"\treturn g\n"
"}\n"
"\n"
"// Function setting the grid span of a Generic\n"
"fn (g: ^Generic) span*(x, y: th.uu): ^Generic {\n"
"\tg.gridSpan.x = x\n"
"\tg.gridSpan.y = y\n"
"\treturn g\n"
"}\n"
"\n"
"// Generic\'s handle function. It checks for events. If you create your own\n"
"// ui element and want to have more control over how events are fired, you\n"
"// don\'t have to use it.\n"
"fn (g: ^Generic) handle*() {\n"
"\tm := input.getMousePos()\n"
"\tif m.x < g.r.x || m.y < g.r.y ||\n"
"\t\tm.x > g.r.x + g.r.w || m.y > g.r.y + g.r.h {\n"
"\t\tif g.pressed {\n"
"\t\t\tg.pressed = false\n"
"\t\t\tg.onEvent(eventRelease, g.ctx)\n"
"\t\t}\n"
"\t\treturn\n"
"\t}\n"
"\t\n"
"\tg.onEvent(eventHover, g.ctx)\n"
"\t\n"
"\tif input.isPressed(input.mouse1) {\n"
"\t\tinput.clear(input.mouse1)\n"
"\n"
"\t\tif !g.pressed {\n"
"\t\t\tg.onEvent(eventJustPress, g.ctx)\n"
"\t\t}\n"
"\n"
"\t\tg.onEvent(eventPress, g.ctx)\n"
"\t\tg.pressed = true\n"
"\t} else if g.pressed {\n"
"\t\tg.pressed = false\n"
"\t\tg.onEvent(eventRelease, g.ctx)\n"
"\t}\n"
"}\n"
"\n"
"fn drawBorder*(p, d: th.Vf2, t: Theme) {\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x, p.y, t.borderSize, d.y))\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x, p.y, d.x, t.borderSize))\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x + d.x - t.borderSize, p.y, t.borderSize, d.y))\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x, p.y + d.y - t.borderSize, d.x, t.borderSize))\n"
"}\n"
"",
"// Umka standard library\n"
"\n"
"// Memory\n"
"\n"
"fn rtlmemcpy(dest, src: ^void, count: int)\n"
"\n"
"fn tobytes*(buf: interface{}): []uint8 {\n"
"    if buf.__self == null {\n"
"        error(\"Buffer is null\")\n"
"    }\n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot access reference types\")\n"
"    }\n"
"    bytes := make([]uint8, sizeofself(buf))\n"
"    rtlmemcpy(&bytes[0], buf.__self, sizeofself(buf))\n"
"    return bytes\n"
"}\n"
"\n"
"fn frombytes*(buf: interface{}, bytes: []uint8) {\n"
"    if buf.__self == null {\n"
"        error(\"Buffer is null\")\n"
"    }    \n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot access reference types\")\n"
"    }\n"
"    if sizeofself(buf) != len(bytes) {\n"
"        error(\"Illegal buffer size\")\n"
"    }\n"
"    rtlmemcpy(buf.__self, &bytes[0], sizeofself(buf))    \n"
"}\n"
"\n"
"// File I/O\n"
"\n"
"type File* = ^struct {}\n"
"\n"
"const (\n"
"    seekBegin* = 0\n"
"    seekCur*   = 1\n"
"    seekEnd*   = 2\n"
")    \n"
"\n"
"fn rtlfopen  (name: str, mode: str): File;  \n"
"fn fopen*    (name: str, mode: str): File {return rtlfopen(name, mode)}\n"
"\n"
"fn rtlfclose (f: File): int\n"
"fn fclose*   (f: File): int {return rtlfclose(f)}\n"
"\n"
"fn rtlfread(buf: ^void, size, cnt: int, f: File): int\n"
"\n"
"fn fread*(f: File, buf: interface{}): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    if bytes := ^[]uint8(buf); bytes != null {\n"
"        return rtlfread(&bytes[0], len(bytes^), 1, f)\n"
"    }\n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot read reference types except ^[]uint8\")\n"
"    }\n"
"    return rtlfread(buf.__self, sizeofself(buf), 1, f)\n"
"}\n"
"\n"
"fn rtlfwrite(buf: ^void, size, cnt: int, f: File): int\n"
"\n"
"fn fwrite*(f: File, buf: interface{}): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    if bytes := ^[]uint8(buf); bytes != null {\n"
"        return rtlfwrite(&bytes[0], len(bytes^), 1, f)\n"
"    }    \n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot write reference types except ^[]uint8\")\n"
"    }\n"
"    return rtlfwrite(buf.__self, sizeofself(buf), 1, f)\n"
"}\n"
"\n"
"fn rtlfseek  (f: File, offset, origin: int): int\n"
"fn fseek*    (f: File, offset, origin: int): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    return rtlfseek(f, offset, origin)\n"
"}\n"
"\n"
"fn rtlftell (f: File): int\n"
"fn ftell*   (f: File): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    return rtlftell(f)\n"
"}\n"
"\n"
"fn rtlremove (name: str): int\n"
"fn remove*   (name: str): int {return rtlremove(name)}\n"
"\n"
"fn rtlfeof  (f: File): int\n"
"fn feof*    (f: File): bool {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }                \n"
"    return bool(rtlfeof(f))\n"
"}\n"
"\n"
"// I/O utilities\n"
"\n"
"fn println*(s: str): int {return printf(\"%s\\n\", s)}\n"
"fn fprintln*(f: File, s: str): int {return fprintf(f, \"%s\\n\", s)}\n"
"\n"
"fn getchar*(): char {\n"
"    var c: char\n"
"    scanf(\"%c\", &c)\n"
"    return c\n"
"}\n"
"\n"
"// Strings\n"
"\n"
"fn ltrim*(s: str): str {\n"
"    start := -1\n"
"    slen := len(s)\n"
"    for i := 0; i < slen; i++ {\n"
"        if s[i] != \' \' && s[i] != \'\\t\' {\n"
"            start = i\n"
"            break\n"
"        } \n"
"    }\n"
"    if start == -1 {return \"\"}\n"
"    return slice(s, start)\n"
"}\n"
"\n"
"fn rtrim*(s: str): str {\n"
"    stop := -1\n"
"    slen := len(s)\n"
"    for i := slen - 1; i >= 0; i-- {\n"
"        if s[i] != \' \' && s[i] != \'\\t\' {\n"
"            stop = i\n"
"            break\n"
"        } \n"
"    }\n"
"    if stop == -1 {return \"\"}\n"
"    return slice(s, 0, stop + 1)\n"
"}\n"
"\n"
"fn trim*(s: str): str {\n"
"    return ltrim(rtrim(s))\n"
"}\n"
"\n"
"// Conversions\n"
"\n"
"fn atoi*(s: str): int {\n"
"    var x: int\n"
"    sscanf(s, \"%lld\", &x)\n"
"    return x\n"
"}\n"
"\n"
"fn atof*(s: str): real {\n"
"    var x: real\n"
"    sscanf(s, \"%lf\", &x)\n"
"    return x\n"
"}\n"
"\n"
"fn itoa*(x: int): str {\n"
"    s := str(make([]char, 256))\n"
"    sprintf(s, \"%lld\", x)\n"
"    return s\n"
"}\n"
"\n"
"fn ftoa*(x: real, decimals: int): str {\n"
"    fmt := str(make([]char, 256))\n"
"    s := str(make([]char, 256))\n"
"    sprintf(fmt, \"%%.%dlf\", decimals)\n"
"    sprintf(s, fmt, x)\n"
"    return s\n"
"}\n"
"\n"
"// Math\n"
"\n"
"const pi* = 3.14159265358979323846\n"
"\n"
"// Random numbers\n"
"\n"
"const randMax* = 0x7FFFFFFF\n"
"randSeed := 0\n"
"\n"
"fn srand*(seed: int) {randSeed = seed}\n"
"\n"
"fn rand*(): int {\n"
"    randSeed = ((randSeed * 1103515245) + 12345) & 0x7FFFFFFF\n"
"    return randSeed\n"
"}\n"
"\n"
"fn frand*(): real {return real(rand()) / randMax}\n"
"\n"
"// Timer\n"
"\n"
"fn rtltime(): int\n"
"fn time*(): int {return rtltime()}\n"
"\n"
"fn rtlclock(): real\n"
"fn clock*(): real {return rtlclock()}\n"
"\n"
"// Command line and environment\n"
"\n"
"fn argc*(): int {return rtlargc}\n"
"\n"
"fn argv*(i: int): str {\n"
"    if i < 0 || i >= rtlargc {\n"
"        error(\"Command line parameter not found\")\n"
"    }\n"
"    return rtlargv[i]\n"
"}\n"
"\n"
"fn rtlgetenv(name: str): str\n"
"fn getenv*(name: str): str {\n"
"    return \"\" + rtlgetenv(name)\n"
"}\n"
"\n"
"",
"//~~\n"
"// Particles allow for *performant* and random particle systems.\n"
"// TODO: a better constructor\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"//~~struct Particle\n"
"// Particle struct. You can tweak the start_time for godot-like explossivness.\n"
"type Particle* = struct {\n"
"//~~\n"
"\tstart_time: uint\n"
"\tseed: int32\n"
"}\n"
"\n"
"//~~struct Emitter\n"
"// Emitter. This is where everything is configured.\n"
"type Emitter* = struct {\n"
"\tpos: th.Vf2 // position\n"
"\tdm: th.Vf2 // size of the emittion area\n"
"\tgravity: th.Vf2 // gravity\n"
"\trepeat: bool // if false, particle won\'t be renewed\n"
"\tactive: bool // false, if there aren\'t any active particles anymore\n"
"\t\n"
"\tangle: th.Vf2 // angle in which particles are emitted\n"
"\n"
"\tlifetime: th.uu // lifetime of particles\n"
"\tlifetimeRandomness: th.fu // randomness in %/100\n"
"\n"
"\tvelocity: th.fu // velocity\n"
"\tvelocityRandomness: th.fu // randomness in %/100\n"
"\n"
"\tsize: th.fu // size\n"
"\tsizeRandomness: th.fu // randomness in %/100\n"
"\tmaxSize: th.fu // size at the end of particles lifetime\n"
"\n"
"\trotation: th.fu\n"
"\trotationRandomness: th.fu\n"
"\tmaxRotation: th.fu\n"
"\n"
"\tcolors: []uint32 // array of colors, which are interpolated between\n"
"\t\n"
"\tparticles: []Particle // list of particles\n"
"}\n"
"//~~\n"
"\n"
"fn umth_particles_draw(p: ^Emitter, cam: ^rect.Rect, t: int32)\n"
"//~~fn Emitter.draw\n"
"// Draws and updates the particles.\n"
"fn (e: ^Emitter) draw*(cam: rect.Rect, t: int32) {\n"
"//~~\n"
"\tif len(e.colors) <= 0 || len(e.particles) <= 0 {\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\tumth_particles_draw(e, &cam, t)\n"
"}\n"
"",
"//~~\n"
"// Simple linear interpolation module.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\t\t\t\t\t\t\t\t\n"
")\n"
"\n"
"// Lerper queue item. It interpolates between start and end for the duration\n"
"// of length in ms. Additionally you can enable swap, which instead of\n"
"// dequeueing swaps start and end and resets the progress.\n"
"type Item* = struct {\n"
"\tstart, end: th.fu\n"
"\tlength: th.uu\n"
"\tprogress: th.fu\n"
"\tswap: bool\n"
"\tctx: any\n"
"\tcallback: fn(ctx: any)\n"
"}\n"
"\n"
"// Item\'s constructor\n"
"fn mk*(start, end: th.fu, length: th.uu, swap: bool = false): Item {\n"
"\treturn Item{\n"
"\t\tstart, end, length, 0, swap, null, fn(ctx: any) {}}\n"
"}\n"
"\n"
"// Lerper is a queue of items. It will lerp the first one and if it ends\n"
"// and doesn\'t have swap enabled, it will dequeue it.\n"
"type Lerper* = []Item\n"
"\n"
"// Removes the first lerper item.\n"
"fn (l: ^Lerper) dequeue*() {\n"
"\tswitch len(l^) {\n"
"\tcase 0:\n"
"\t\treturn\n"
"\tcase 1:\n"
"\t\tl^ = Lerper{}\n"
"\tdefault:\n"
"\t\tl^ = slice(l^, 1)\n"
"\t}\n"
"}\n"
"\n"
"// Adds an item to l\'s queue\n"
"fn (l: ^Lerper) enqueue*(i: Item) {\n"
"\tl^ = append(l^, i)\n"
"}\n"
"\n"
"// Interpolates the front by delta. And returns it\'s value.\n"
"fn (l: ^Lerper) byDelta*(delta: th.uu): th.fu {\n"
"\tif len(l^) == 0 {\n"
"\t\treturn 0\n"
"\t}\n"
"\n"
"\t/*for l[0].progress >= 1.0 {\n"
"\t\tl[0].callback(l[0].ctx)\n"
"\n"
"\t\tif l[0].swap {\n"
"\t\t\ttmp := l[0].start\n"
"\t\t\tl[0].start = l[0].end\n"
"\t\t\tl[0].end = tmp\n"
"\n"
"\t\t\tl[0].progress = 0\n"
"\t\t\tbreak\n"
"\t\t}\n"
"\n"
"\t\tl.dequeue()\n"
"\t\tif len(l^) == 0 {\n"
"\t\t\treturn 0\n"
"\t\t}\n"
"\t}*/\n"
"\n"
"\tif l[0].progress >= 1 {\n"
"\t\tend := l[0].end\n"
"\t\tl.dequeue()\n"
"\t\treturn end\n"
"\t}\n"
"\n"
"\tl[0].progress += th.fu(delta)/l[0].length\n"
"\n"
"\treturn l[0].progress * (l[0].end-l[0].start) + l[0].start\n"
"}\n"
"",
"//~~\n"
"// Module for font rendering. Unicode is supported, but only left to right.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"//~~Filtering constants\n"
"const (\n"
"\tfilterNearest* = 0\n"
"\tfilterLinear* = 1\n"
")\n"
"//~~\n"
"\n"
"//~~opaque Font\n"
"type Font* = struct { _: ^struct{} }\n"
"//~~\n"
"\n"
"\n"
"fn umth_font_load(path: str, size: th.fu, filter: uint32): ^struct{}\n"
"//~~fn load\n"
"fn load*(path: str, size: th.fu, filter: uint32 = filterLinear): Font {\n"
"//~~\n"
"\treturn Font{umth_font_load(path, size, filter)}\n"
"}\n"
"\n"
"fn umth_font_draw(font: Font, s: str, x: th.fu, y: th.fu, color: uint32, scale: th.fu)\n"
"//~~fn Font.draw\n"
"fn (f: ^Font) draw*(text: str, pos: th.Vf2, color: uint32, scale: th.fu = 1.0) {\n"
"//~~\n"
"\tumth_font_draw(f^, text, pos.x, pos.y, color, scale)\n"
"}\n"
"\n"
"//~~fn Font.validate\n"
"fn (f: ^Font) validate*(): bool {\n"
"//~~\n"
"\treturn f._ != null\n"
"}\n"
"\n"
"fn umth_font_measure(font: Font, s: str, o: ^th.Vf2)\n"
"//~~fn Font.measure\n"
"fn (f: ^Font) measure*(text: str): th.Vf2 {\n"
"//~~\n"
"\tvar size: th.Vf2\n"
"\tumth_font_measure(f^, text, &size)\n"
"\treturn size\n"
"}\n"
"",
"//~~\n"
"// Module with useful variables and types.\n"
"// Variables: time, delta, platform\n"
"// Constants: black, white, red, green, blue, yellow, magenta, cyan.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"std.um\"\n"
")\n"
"\n"
"//~~Tophat type aliases\n"
"// standard type for real values\n"
"type fu* = real32\n"
"// standard type for integer values\n"
"type iu* = int32\n"
"// standard type for unsigned values\n"
"type uu* = uint32\n"
"//~~\n"
"\n"
"//~~struct Vf2\n"
"// vector 2\n"
"type Vf2* = struct {\n"
"\tx, y: fu\n"
"}\n"
"//~~\n"
"\n"
"//~~fn mkVf2\n"
"// Vf2 constructor\n"
"fn mkVf2*(x: fu = 0, y: fu = 0): Vf2 {\n"
"\treturn Vf2{x, y}\n"
"}\n"
"//~~\n"
"\n"
"//~~fn Vf2.rotated\n"
"// rotates `p` around `origin` with `rot` in degrees\n"
"fn (p: ^Vf2) rotated*(origin: Vf2, rot: fu): Vf2 {\n"
"//~~\n"
"\tangle := (rot * std.pi) / 180\n"
"\n"
"\tpos := p^\n"
"\tpos.x -= origin.x\n"
"\tpos.y -= origin.y\n"
"\n"
"\tx := pos.x * cos(angle) - pos.y * sin(angle)\n"
"\ty := pos.x * sin(angle) + pos.y * cos(angle)\n"
"\n"
"\tpos.x = x + origin.x\n"
"\tpos.y = y + origin.y\n"
"\n"
"\treturn pos\n"
"}\n"
"\n"
"//~~fn Vf2.distanceTo\n"
"// distance between p1 and p2\n"
"fn (p1: ^Vf2) distanceTo*(p2: Vf2): fu {\n"
"//~~\n"
"\treturn sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y))\n"
"}\n"
"\n"
"//~~fn Vf2.angleTo\n"
"// Angle between p1 and p2\n"
"fn (p1: ^Vf2) angleTo*(p2: Vf2): real {\n"
"//~~\n"
"\tif p1.x == p2.x && p1.y == p2.y { return 0 }\n"
"\treturn atan2(p2.y - p1.y, p2.x - p1.x) * 180 / std.pi + 180\n"
"}\n"
"\n"
"//~~fn Vf2.abs\n"
"// Absolute value of a vector.\n"
"fn (p: ^Vf2) abs*(): Vf2 {\n"
"//~~\n"
"\treturn Vf2{fabs(p.x), fabs(p.y)}\n"
"}\n"
"\n"
"//~~fn Vf2.round\n"
"// Rounds a vector.\n"
"fn (p: ^Vf2) round*(): Vf2 {\n"
"//~~\n"
"\treturn Vf2{round(p.x), round(p.y)}\n"
"}\n"
"\n"
"//~~fn Vf2.trunc\n"
"// Truncates a vector.\n"
"fn (p: ^Vf2) trunc*(): Vf2 {\n"
"//~~\n"
"\treturn Vf2{trunc(p.x), trunc(p.y)}\n"
"}\n"
"\n"
"//~~fn Vf2.floor\n"
"// Floors a vector.\n"
"fn (p: ^Vf2) floor*(): Vf2 {\n"
"//~~\n"
"\treturn Vf2{floor(p.x), floor(p.y)}\n"
"}\n"
"\n"
"//~~fn Vf2.ceil\n"
"// Ceils a vector.\n"
"fn (p: ^Vf2) ceil*(): Vf2 {\n"
"//~~\n"
"\treturn Vf2{ceil(p.x), ceil(p.y)}\n"
"}\n"
"\n"
"//~~fn vf2f\n"
"// Creates a vector with both x and y set to f\n"
"fn vf2f*(f: fu): Vf2 {\n"
"//~~\n"
"\treturn Vf2{f, f}\n"
"}\n"
"\n"
"//~~fn Vf2.sub\n"
"// Subtracts a vector from another one.\n"
"fn (p: ^Vf2) sub*(p2: Vf2): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x - p2.x, p.y - p2.y}\n"
"}\n"
"\n"
"//~~fn Vf2.subf\n"
"// Subtracts a fu from a vector.\n"
"fn (p: ^Vf2) subf*(f: fu): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x - f, p.y - f}\n"
"}\n"
"\n"
"//~~fn Vf2.add\n"
"// Adds a vector to another one.\n"
"fn (p: ^Vf2) add*(p2: Vf2): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x + p2.x, p.y + p2.y}\n"
"}\n"
"\n"
"//~~fn Vf2.addf\n"
"// Adds a fu to a vector.\n"
"fn (p: ^Vf2) addf*(f: fu): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x + f, p.y + f}\n"
"}\n"
"\n"
"//~~fn Vf2.div\n"
"// Divides a vector by another one.\n"
"fn (p: ^Vf2) div*(p2: Vf2): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x / p2.x, p.y / p2.y}\n"
"}\n"
"\n"
"//~~fn Vf2.divf\n"
"// Divides a vector by a fu.\n"
"fn (p: ^Vf2) divf*(f: fu): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x / f, p.y / f}\n"
"}\n"
"\n"
"//~~fn Vf2.mul\n"
"// Multiplies a vector by another one.\n"
"fn (p: ^Vf2) mul*(p2: Vf2): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x * p2.x, p.y * p2.y}\n"
"}\n"
"\n"
"//~~fn Vf2.mulf\n"
"// Multiplies a vector by a fu.\n"
"fn (p: ^Vf2) mulf*(f: fu): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x * f, p.y * f}\n"
"}\n"
"\n"
"//~~fn Vf2.mag\n"
"// Returns the magnitude of a vector p.\n"
"fn (p: ^Vf2) mag*(): fu {\n"
"//~~\n"
"\treturn sqrt(p.x * p.x + p.y * p.y)\n"
"}\n"
"\n"
"//~~fn Vf2.norm\n"
"// Normalizes a vector.\n"
"fn (p: ^Vf2) norm*(): Vf2 {\n"
"//~~\n"
"\tif p.x == 0 && p.y == 0 {\n"
"\t\treturn p^\n"
"\t}\n"
"\n"
"\treturn p.divf(p.mag())\n"
"}\n"
"\n"
"//~~fn Vf2.dot\n"
"// Calculates dot product between 2 vectors.\n"
"fn (p: ^Vf2) dot*(q: Vf2): fu {\n"
"//~~\n"
"\treturn p.x*q.x + p.y*q.y\n"
"}\n"
"\n"
"//~~struct Transform\n"
"// Struct defining transformation. Used for example by entities.\n"
"type Transform* = struct {\n"
"\tp: Vf2 // position\n"
"\ts: Vf2 // scale\n"
"\to: Vf2 // origin\n"
"\tr: fu  // rotation\n"
"}\n"
"//~~\n"
"\n"
"//~~fn mkTransform\n"
"// Transform constructor\n"
"fn mkTransform*(p: Vf2, s: Vf2 = Vf2{1, 1}, o: Vf2 = Vf2{0, 0}, r: fu = 0.0): Transform {\n"
"//~~\n"
"\treturn Transform{p: p, s: s, o: o, r: r}\n"
"}\n"
"\n"
"fn umth_transform_transform(o, t: ^Transform)\n"
"//~~fn Transform.transformed\n"
"// Transforms a transform with another transform.\n"
"fn (o: ^Transform) transformed*(t: Transform): Transform {\n"
"//~~\n"
"\tret := o^\n"
"\tumth_transform_transform(&ret, &t)\n"
"\n"
"\treturn ret\n"
"}\n"
"\n"
"fn umth_transform_vf2(v: ^Vf2, t: ^Transform)\n"
"//~~fn Vf2.transformed\n"
"// Transforms a vf2 to another vf2.\n"
"// Order:\n"
"// \t1. scale\n"
"// \t2. rotation\n"
"// \t3. position\n"
"// \n"
"// This allows conversion from a relative to an absolute vf2.\n"
"fn (v: ^Vf2) transformed*(t: Transform): Vf2 {\n"
"//~~\n"
"\tret := v^\n"
"\tumth_transform_vf2(&ret, &t)\n"
"\treturn ret\n"
"}\n"
"\n"
"//~~type Quad\n"
"type Quad* = [4]Vf2\n"
"//~~\n"
"\n"
"fn umth_transform_quad(q: ^Quad, t: ^Transform)\n"
"//~~fn Quad.transformed\n"
"// Transforms a quad into another quad.\n"
"// Order:\n"
"// \t1. scale\n"
"// \t2. rotation\n"
"// \t3. position\n"
"fn (q: ^Quad) transformed*(t: Transform): Quad {\n"
"//~~\n"
"\tret := q^\n"
"\tumth_transform_quad(&ret, &t)\n"
"\treturn ret\n"
"}\n"
"\n"
"//~~fn Quad.getDims\n"
"// Returns the dimensions of the quad\'s bounding box\n"
"fn (q: ^Quad) getDims*(): Vf2 {\n"
"//~~\n"
"\tmax := q[0]\n"
"\tmin := q[0]\n"
"\n"
"\tmaxmag := max.mag()\n"
"\tminmag := min.mag()\n"
"\n"
"\tfor i:=1; i < len(q^); i++ {\n"
"\t\tqmag := q[i].mag()\n"
"\n"
"\t\tif maxmag < qmag {\n"
"\t\t\tmax = q[i]\n"
"\t\t\tmaxmag = qmag\n"
"\t\t}\n"
"\n"
"\t\tif minmag > qmag {\n"
"\t\t\tmin = q[i]\n"
"\t\t\tminmag = qmag\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn max.sub(min)\n"
"}\n"
"\n"
"fn umth_th_getglobal(): ^struct{}\n"
"//~~fn getGlobal\n"
"// returns a pointer to the th_global. Set this as your extensions thg.\n"
"fn getGlobal*(): ^struct{} {\n"
"//~~\n"
"\treturn umth_th_getglobal()\n"
"}\n"
"\n"
"fn umth_th_getfuncs(): ^struct{}\n"
"//~~fn getFuncs\n"
"// returns pointer to tophat functions. Pass this to th_ext_set.\n"
"fn getFuncs*(): ^struct{} {\n"
"//~~\n"
"\treturn umth_th_getfuncs()\n"
"}\n"
"\n"
"//~~Color constants\n"
"const (\n"
"\tblack* = 0xff\n"
"\twhite* = 0xffffffff\n"
"\tred* = 0xff0000ff\n"
"\tgreen* = 0x00ff00ff\n"
"\tblue* = 0x0000ffff\n"
"\tyellow* = 0xffff00ff\n"
"\tmagenta* = 0xff00ffff\n"
"\tcyan* = 0x00ffffff\n"
")\n"
"//~~\n"
"\n"
"//~~enum Platform\n"
"type Platform* = int\n"
"const (\n"
"\tPlatformUnknown* = 0\n"
"\tPlatformLinux*\n"
"\tPlatformWindows*\n"
"\tPlatformMacOs*\n"
"\tPlatformWeb*\n"
")\n"
"//~~\n"
"\n"
"//~~Misc variables\n"
"var (\n"
"\t// time in ms from start of the game\n"
"\ttime*: uint\n"
"\t// length of the last frame in ms\n"
"\tdelta*: int\n"
"\t// platform tophat is running on\n"
"\tplatform*: Platform\n"
")\n"
"//~~\n"
"",
"//~~\n"
"// A module for importless communication between modules. A signal is a set of\n"
"// callbacks.  You can use signals directly in your own structs if you want\n"
"// them to be instance specific, of you can use global signals which are\n"
"// adressed by a string name.\n"
"//~~\n"
"\n"
"//~~type Callback\n"
"// `cctx` is value passed by the caller to `emit`. `uctx` is the value passed\n"
"// to the register function.\n"
"type Callback* = fn(cctx, uctx: any) \n"
"//~~\n"
"\n"
"type User* = struct {\n"
"\tfunc: Callback\n"
"\tuctx: any\n"
"}\n"
"\n"
"//~~type Id\n"
"type Id* = uint\n"
"//~~\n"
"\n"
"//~~type Signal\n"
"type Signal* = map[Id]User\n"
"//~~\n"
"\n"
"var signals: map[str]Signal\n"
"var idCounter: Id\n"
"\n"
"//~~fn mk\n"
"// `Signal` constructor\n"
"fn mk*(): Signal {\n"
"//~~\n"
"\treturn make(Signal)\n"
"}\n"
"\n"
"//~~fn Signal.register\n"
"// Registers a callback to a signal and returns the callback id.\n"
"fn (this: ^Signal) register*(callback: Callback, uctx: any): Id {\n"
"//~~\n"
"\tidCounter++\n"
"\tthis[idCounter] = User{ callback, uctx }\n"
"\n"
"\treturn idCounter\n"
"}\n"
"\n"
"//~~fn Signal.remove\n"
"// Removes a callback by id.\n"
"fn (this: ^Signal) remove*(id: Id) {\n"
"//~~\n"
"\tdelete(this^, id)\n"
"}\n"
"\n"
"//~~fn Signal.emit\n"
"// Emits a signal.\n"
"fn (this: ^Signal) emit*(ctx: any) {\n"
"//~~\n"
"\tfor c in this {\n"
"\t\tthis[c].func(ctx, this[c].uctx)\n"
"\t}\n"
"}\n"
"\n"
"//~~fn Signal.clear\n"
"// Removes all signal handlers.\n"
"fn (this: ^Signal) clear*() {\n"
"//~~\n"
"\tks := keys(this^)\n"
"\n"
"\tfor i, k in ks {\n"
"\t\tthis ^= delete(this^, k)\n"
"\t}\n"
"}\n"
"\n"
"//~~fn register\n"
"// Registers a callback to a global signal.  There is no need to explicitly\n"
"// create global signals.  Returns id of the added callback\n"
"fn register*(name: str, callback: Callback, uctx: any): Id {\n"
"//~~\n"
"\tif !valid(signals) {\n"
"\t\tsignals = make(map[str]Signal)\n"
"\t}\n"
"\n"
"\treturn signals[name].register(callback, uctx)\n"
"}\n"
"\n"
"//~~fn remove\n"
"// Removes a callback from a global signal by id.\n"
"fn remove*(name: str, id: Id) {\n"
"//~~\n"
"\tsignals[name].remove(id)\n"
"}\n"
"\n"
"//~~fn remove\n"
"// Removes all signal handlers from a global signal.\n"
"fn clear*(name: str) {\n"
"//~~\n"
"\tsignals[name].clear()\n"
"}\n"
"\n"
"//~~fn emit\n"
"// Calls all callbacks associated with the passed global signal name.\n"
"fn emit*(name: str, ctx: any) {\n"
"//~~\n"
"\tif !valid(signals) {\n"
"\t\tsignals = make(map[str]Signal)\n"
"\t}\n"
"\n"
"\tsignals[name].emit(ctx)\n"
"}\n"
"\n"
"\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"image.um\"\n"
")\n"
"\n"
"//~~struct Atlas\n"
"// Atlas is an image containing tiles in a square grid.\n"
"type Atlas* = struct {\n"
"\ti: image.Image // source image\n"
"\tcs: th.Vf2 // size of a cell in pixels\n"
"\tdm: th.Vf2 // amount of cells in image\n"
"}\n"
"//~~\n"
"\n"
"//~~fn mk\n"
"// i: source image\n"
"// dm: amount of cells\n"
"fn mk*(i: image.Image, dm: th.Vf2): Atlas {\n"
"//~~\n"
"\ta := Atlas{}\n"
"\n"
"\ta.i = i\n"
"\ta.dm = dm\n"
"\ta.cs = i.getDims().div(dm)\n"
"\n"
"\treturn a\n"
"}\n"
"\n"
"//~~fn Atlas.coords\n"
"// returns the coordinates of the nth tile\n"
"fn (a: ^Atlas) coords*(n: int): th.Vf2 {\n"
"//~~\n"
"\treturn th.Vf2{ n % trunc(a.dm.x), (n - n % trunc(a.dm.x)) / a.dm.x }\n"
"}\n"
"\n"
"//~~fn Atlas.cropSource\n"
"// Crops the sourse image to only show a wanted tile\n"
"fn (a: ^Atlas) cropSource*(at: th.Vf2) {\n"
"//~~\n"
"\tif (at.x > a.dm.x || at.y > a.dm.y || at.x * at.y < 0) {\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\ta.i.crop(\n"
"\t\tth.Vf2{at.x / a.dm.x, at.y / a.dm.y},\n"
"\t\tth.Vf2{(at.x+1) / a.dm.x, (at.y+1) / a.dm.y})\n"
"}\n"
"\n"
"//~~fn Atlas.draw\n"
"// Draws the tile at `at`\n"
"fn (a: ^Atlas) draw*(at: th.Vf2, t: th.Transform) {\n"
"//~~\n"
"\ta.cropSource(at)\n"
"\ta.i.draw(t, th.white)\n"
"\ta.i.crop(th.Vf2{}, th.Vf2{1, 1})\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"utf8.um\"\n"
"\t\"rect.um\"\n"
"\t\"ui.um\"\n"
"\t\"canvas.um\"\n"
")\n"
"\n"
"// An element containing a TextRenderer. The text renderer supports\n"
"// word-wrapping and centered text.\n"
"type Label* = struct {\n"
"\tg: ui.Generic\n"
"\ttext: str\n"
"\trenderer: ui.TextRenderer\n"
"\tcenter: bool\n"
"\twrapping: bool\n"
"\tscale: th.fu\n"
"}\n"
"\n"
"// Label constructor\n"
"fn mk*(f: ui.TextRenderer, text: str, theme: ui.Theme, scale: th.fu, center: bool = false, wrapping: bool = false): Label {\n"
"\tl := Label{}\n"
"\tl.g = ui.mkGeneric()\n"
"\tl.g.theme = theme\n"
"\tl.text = text\n"
"\tl.renderer = f\n"
"\tl.scale = scale\n"
"\tl.center = center\n"
"\tl.wrapping = wrapping\n"
"\n"
"\treturn l\n"
"}\n"
"\n"
"fn (l: ^Label) get*(): ^ui.Generic {\n"
"\treturn &l.g\n"
"}\n"
"\n"
"fn (l: ^Label) handle*() {\n"
"\tl.g.handle()\n"
"}\n"
"\n"
"fn (l: ^Label) draw*() {\n"
"\tif len(l.text) == 0 {\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\tcanvas.drawRect(l.g.theme.bg, rect.Rect{l.g.r.x, l.g.r.y, l.g.r.w, l.g.r.h})\n"
"\tui.drawBorder(l.g.r.getPos(), l.g.r.getDims(), l.g.theme)\n"
"\n"
"\ttext := utf8.decode(l.text)\n"
"\t// hack to wrap the last word too\n"
"\ttext = append(text, uint32(\' \'))\n"
"\tlineCount := 1\n"
"\n"
"\tlines := [][]utf8.Rune{}\n"
"\n"
"\tif l.wrapping {\n"
"\t\tlimit := l.g.r.w - l.g.theme.borderSize * 2\n"
"\t\twordStart := 0\n"
"\t\tlineWidth := 0.0\n"
"\n"
"\t\tfor i:=0; i < len(text); i++ {\n"
"\t\t\tif text[i] == uint32(\' \') {\n"
"\t\t\t\tif lineWidth > limit {\n"
"\t\t\t\t\tlines = append(lines, slice(text, 0, wordStart - 1))\n"
"\t\t\t\t\ttext = slice(text, wordStart)\n"
"\n"
"\t\t\t\t\twordStart = 0\n"
"\t\t\t\t\tlineWidth = 0\n"
"\t\t\t\t\ti = -1\n"
"\t\t\t\t\tcontinue\n"
"\t\t\t\t}\n"
"\n"
"\t\t\t\twordStart = i + 1\n"
"\t\t\t\tlineWidth += l.renderer.measure(\" \").x * l.scale\n"
"\t\t\t} else if text[i] == uint32(\'\\n\') {\n"
"\t\t\t\tlines = append(lines, slice(text, 0, i))\n"
"\t\t\t\ttext = slice(text, i + 1)\n"
"\n"
"\t\t\t\twordStart = 0\n"
"\t\t\t\tlineWidth = 0\n"
"\t\t\t\ti = -1\n"
"\t\t\t} else {\n"
"\t\t\t\tlineWidth += l.renderer.measure(text[i].encode()).x * l.scale\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\t// we have to remove the space again to prevent alignment issues\n"
"\t\tlines = append(lines, slice(text, 0, len(text) - 1))\n"
"\t} else {\n"
"\t\tlines = append(lines, text)\n"
"\t}\n"
"\n"
"\tx := l.g.r.x + l.g.theme.borderSize\n"
"\ty := l.g.r.y\n"
"\tif l.center {\n"
"\t\ty += (l.g.r.h - len(lines) * l.renderer.measure(\"A\").y * l.scale) / 2\n"
"\t}\n"
"\n"
"\tfor i in lines {\n"
"\t\ts := \"\"\n"
"\t\tfor j in lines[i] {\n"
"\t\t\ts += lines[i][j].encode()\n"
"\t\t}\n"
"\n"
"\t\tp := th.Vf2{\n"
"\t\t\tx: x,\n"
"\t\t\ty: y }\n"
"\n"
"\t\tif l.center {\n"
"\t\t\tp.x += (l.g.r.w - l.renderer.measure(s).x * l.scale) / 2 + l.g.theme.borderSize / 2\n"
"\t\t}\n"
"\n"
"\t\tl.renderer.draw(s, p, l.g.theme.fg, l.scale)\n"
"\n"
"\t\ty += l.renderer.measure(s).y * l.scale\n"
"\t}\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"ui.um\"\n"
")\n"
"\n"
"// A Grid container. The grid size is fixed, not dynamic like in Tk.\n"
"type Grid* = struct {\n"
"\tg: ui.Generic\n"
"\tw, h: th.uu\n"
"\tborder: th.fu\n"
"\telements: []ui.Element\n"
"}\n"
"\n"
"// Grid\'s constructor\n"
"fn mk*(w, h: th.uu, border: th.fu = 0): Grid {\n"
"\treturn Grid {\n"
"\t\tg: ui.mkGeneric(),\n"
"\t\tw: w, h: h, border: border}\n"
"}\n"
"\n"
"fn (g: ^Grid) get*(): ^ui.Generic {\n"
"\treturn &g.g\n"
"}\n"
"\n"
"fn (g: ^Grid) handle*() {\n"
"\tcellSize := th.Vf2{g.g.r.w/g.w, g.g.r.h/g.h}\n"
"\n"
"\tfor i:=0; i < len(g.elements); i++ {\n"
"\t\te := &g.elements[i]\n"
"\t\tge := e.get()\n"
"\n"
"\t\tif ge.gridPos.x > g.w || ge.gridPos.y > g.h {\n"
"\t\t\terror(\"ui.Grid: out of bounds.\")\n"
"\t\t}\n"
"\n"
"\t\tge.r.x = ge.gridPos.x * cellSize.x\n"
"\t\tge.r.y = ge.gridPos.y * cellSize.y\n"
"\t\t// divide by to as there are two borders\n"
"\t\tge.r.x += g.border/2 + g.g.r.x\n"
"\t\tge.r.y += g.border/2 + g.g.r.y\n"
"\n"
"\t\tif ge.gridPos.x + ge.gridSpan.x > g.w ||\n"
"\t\t\tge.gridPos.y + ge.gridSpan.y > g.h {\n"
"\t\t\terror(\"ui.Grid: out of bounds.\")\n"
"\t\t}\n"
"\n"
"\t\tif ge.gridSpan.x == 0 {\n"
"\t\t\tge.gridSpan.x = 1\n"
"\t\t}\n"
"\n"
"\t\tif ge.gridSpan.y == 0 {\n"
"\t\t\tge.gridSpan.y = 1\n"
"\t\t}\n"
"\n"
"\t\tge.r.w = ge.gridSpan.x * cellSize.x\n"
"\t\tge.r.h = ge.gridSpan.y * cellSize.y\n"
"\t\t// don\'t divide by two as size is relative to position\n"
"\t\tge.r.w -= g.border\n"
"\t\tge.r.h -= g.border\n"
"\n"
"\t\te.handle()\n"
"\t}\n"
"}\n"
"\n"
"fn (g: ^Grid) draw*() {\n"
"\tfor i, e in g.elements {\n"
"\t\te.draw()\n"
"\t}\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"ui.um\"\n"
"\t\"image.um\"\n"
")\n"
"\n"
"// An element containing an image\n"
"type Image* = struct {\n"
"\tg: ui.Generic\n"
"\timage: image.Image\n"
"\tstretch: bool\n"
"}\n"
"\n"
"fn mk*(i: image.Image, stretch: bool = false): Image {\n"
"\treturn Image {\n"
"\t\tg: ui.Generic{},\n"
"\t\timage: i,\n"
"\t\tstretch: stretch}\n"
"}\n"
"\n"
"fn (i: ^Image) get*(): ^ui.Generic {\n"
"\treturn &i.g\n"
"}\n"
"\n"
"fn (i: ^Image) handle*() {\n"
"\ti.g.handle()\n"
"}\n"
"\n"
"fn (i: ^Image) draw*() {\n"
"\tdm := i.image.getDims()\n"
"\ts := th.Vf2{}\n"
"\tif i.stretch {\n"
"\t\ts.x = i.g.r.w/dm.x\n"
"\t\ts.y = i.g.r.h/dm.y\n"
"\t} else {\n"
"\t\tif i.g.r.w < i.g.r.h {\n"
"\t\t\ts.x = i.g.r.w/dm.x\n"
"\t\t\ts.y = s.x\n"
"\t\t\ti.g.r.y += (i.g.r.h - s.y*dm.y)/2\n"
"\t\t} else {\n"
"\t\t\ts.y = i.g.r.h/dm.y\n"
"\t\t\ts.x = s.y\n"
"\t\t\ti.g.r.x += (i.g.r.w - s.x*dm.x)/2\n"
"\t\t}\n"
"\t}\n"
"\n"
"\ti.image.draw(th.Transform{p: i.g.r.getPos(), s: s}, th.white)\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"//~~opaque Shader\n"
"// Shader allows you to define your own vertex and fragment GLSL shaders. This\n"
"// is a low-level feature, so it\'s very easy to mess up.\n"
"//  \n"
"// In tophat, instead of a main function, shaders provide th_vertex and\n"
"// th_fragment. The signature of th_vertex is:\n"
"// \n"
"// ```\n"
"// vec2 th_vertex(vec2 vert);\n"
"// ```\n"
"// \n"
"// where vert is the position of the vertex taken from the vertex buffer.\n"
"// The output is the vertex shader output.\n"
"//  \n"
"// As for fragment shaders, there are two types of them. One for canvas\n"
"// and one for images. In canvas shaders, the fragment function is very simple:\n"
"// \n"
"// ```\n"
"// vec4 th_fragment(vec4 color);\n"
"// ```\n"
"//  \n"
"// Image fragment function looks like this:\n"
"//  \n"
"// ```\n"
"// vec4 th_fragment(sampler2D tex, vec2 coord);\n"
"// ```\n"
"//  \n"
"// where tex is the texture and coord are the texture coordinates. Be aware to\n"
"// swap the output of the `texture2D` function. Example:\n"
"// \n"
"// ```\n"
"// texture2D(tex, coord).abgr\n"
"// ```\n"
"type Shader* = struct {\n"
"//~~\n"
"\thandle: int\n"
"}\n"
"\n"
"\n"
"//~~Default shader constants\n"
"const (\n"
"\tdefaultImageShader* = Shader{1}\n"
"\tdefaultCanvasShader* = Shader{2}\n"
")\n"
"//~~\n"
"\n"
"//~~struct Uniform\n"
"// Represents a GLSL uniform.\n"
"type Uniform* = struct {\n"
"\ts: Shader\n"
"\tl: uint\n"
"}\n"
"//~~\n"
"\n"
"fn umth_shader_compile_canvas(vertex, fragment: str): int\n"
"//~~fn mkCanvas\n"
"// Compiles a canvas shader from source. If there is a compilation error, it\n"
"// will print something to the console.\n"
"fn mkCanvas*(vertex, fragment: str): Shader {\n"
"//~~\n"
"\treturn Shader{umth_shader_compile_canvas(vertex, fragment)}\n"
"}\n"
"\n"
"fn umth_shader_compile_image(vertex, fragment: str): int\n"
"//~~fn mkImage\n"
"// Compiles an image shader from source. If there is a compilation error, it\n"
"// will print something to the console.\n"
"fn mkImage*(vertex, fragment: str): Shader {\n"
"//~~\n"
"\treturn Shader{umth_shader_compile_image(vertex, fragment)}\n"
"}\n"
"\n"
"fn umth_shader_pick_canvas(handle: int)\n"
"//~~fn Shader.pickForCanvas\n"
"// Picks the shader to be used for canvas drawing. Flushes the canvas batch.\n"
"fn (s: ^Shader) pickForCanvas*() {\n"
"//~~\n"
"\tumth_shader_pick_canvas(s.handle)\n"
"}\n"
"\n"
"fn umth_shader_pick_image(handle: int)\n"
"//~~fn Shader.pickForImage\n"
"// Picks the shader to be used for image drawing. Flushes the image batch.\n"
"fn (s: ^Shader) pickForImage*() {\n"
"//~~\n"
"\tumth_shader_pick_image(s.handle)\n"
"}\n"
"\n"
"fn umth_shader_get_uniform_location(handle: int, name: str): uint\n"
"//~~fn Shader.getUniformLocation\n"
"// Retunrs a uniform by name.\n"
"fn (s: ^Shader) getUniformLocation*(name: str): Uniform {\n"
"//~~\n"
"\treturn Uniform{s^, umth_shader_get_uniform_location(s.handle, name)}\n"
"}\n"
"\n"
"fn umth_shader_set_uniform_int(shandle, uhandle: uint, value: int)\n"
"//~~fn Uniform.setInt\n"
"// Sets a uniform to an int value. Flushes both batches.\n"
"fn (u: ^Uniform) setInt*(value: int) {\n"
"//~~\n"
"\tumth_shader_set_uniform_int(u.s.handle, u.l, value)\n"
"}\n"
"\n"
"fn umth_shader_set_uniform_vf2(shandle, uhandle: uint, value: th.Vf2)\n"
"//~~fn Uniform.setVf2\n"
"// Sets a uniform to a vf2. Flushes both batches.\n"
"fn (u: ^Uniform) setVf2*(value: th.Vf2) {\n"
"//~~\n"
"\tumth_shader_set_uniform_vf2(u.s.handle, u.l, value)\n"
"}\n"
"",
"//~~\n"
"// Color operations. Operate on RGBA uint32 values.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"fn umth_hsv2rgb_uint32(h, s, v, a: th.fu): uint32\n"
"\n"
"// Now this is hard to decide, but in my opinion executing a C function,\n"
"//   for the current Umka VM would be much better than implementing it in umka itself.\n"
"// It\'s somewhat less trivial than most other operations like alpha.\n"
"fn umth_rgb_uint32(r, g, b, a: th.fu): uint32\n"
"\n"
"//~~fn hsv\n"
"// Converts HSV values into RGBA uint32 color.\n"
"// NOTE: Hue is between 0 and 1\n"
"fn hsv*(h, s, v: th.fu, a: th.fu = 1.0): uint32 {\n"
"//~~\n"
"\treturn umth_hsv2rgb_uint32(h, s, v, a);\n"
"}\n"
"\n"
"//~~fn alpha\n"
"// Sets alpha of the color c to a value in to.\n"
"fn alpha*(c: uint32, to: th.fu): uint32 {\n"
"//~~\n"
"\treturn (c & 0xFFFFFF00) | (trunc(to * 255) & 0xFF)\n"
"}\n"
"\n"
"//~~fn rgb\n"
"// Constructs RGBA uint32 from RGBA of reals.\n"
"fn rgb*(r, g, b: th.fu, a: th.fu = 1.0): uint32 {\n"
"//~~\n"
"\treturn umth_rgb_uint32(r, g, b, a)\n"
"}\n"
"\n"
"",
"//~~\n"
"// Builtin collision functions. The ic argument stores the collision position.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"fn umth_coll_line_to_line(b1, e1, b2, e2, ic: ^th.Vf2): bool\n"
"//~~fn lineToLine\n"
"// Checks for a collision between 2 lines specified by their end points.\n"
"fn lineToLine*(b1, e1, b2, e2: th.Vf2, ic: ^th.Vf2): bool {\n"
"//~~\n"
"\treturn umth_coll_line_to_line(&b1, &e1, &b2, &e2, ic)\n"
"}\n"
"\n"
"fn umth_coll_point_to_quad(p: ^th.Vf2, q: ^th.Quad, ic: ^th.Vf2): bool\n"
"//~~fn vf2ToQuad\n"
"// Checks for a collision between a vf2 and a quad.\n"
"fn vf2ToQuad*(p: th.Vf2, q: th.Quad, ic: ^th.Vf2): bool {\n"
"//~~\n"
"\treturn umth_coll_point_to_quad(&p, &q, ic)\n"
"}\n"
"\n"
"fn umth_coll_line_to_quad(b, e: ^th.Vf2, q: ^th.Quad, ic: ^th.Vf2): bool\n"
"//~~fn lineToQuad\n"
"// Check for a collision between a line and quad edges.\n"
"fn lineToQuad*(b, e: th.Vf2, q: th.Quad, ic: ^th.Vf2): bool {\n"
"//~~\n"
"\treturn umth_coll_line_to_quad(&b, &e, &q, ic)\n"
"}\n"
"\n"
"fn umth_coll_quad_to_quad(q1, q2: ^th.Quad, ic: ^th.Vf2): bool\n"
"//~~fn quadToQuad\n"
"// Check for a collision between two quads.\n"
"fn quadToQuad*(q1, q2: th.Quad, ic: ^th.Vf2): bool {\n"
"//~~\n"
"\treturn umth_coll_quad_to_quad(&q1, &q2, ic)\n"
"}\n"
"\n"
"fn umth_coll_point_to_rect(p: th.Vf2, r: ^rect.Rect): bool\n"
"//~~fn vf2ToRect\n"
"// Check for a collision between a vf2 and a rectangle.\n"
"fn vf2ToRect*(p: th.Vf2, r: rect.Rect): bool {\n"
"//~~\n"
"\treturn umth_coll_point_to_rect(p, &r)\n"
"}\n"
"\n"
"fn umth_coll_rect_to_rect(r1, r2: ^rect.Rect): bool\n"
"//~~fn rectToRect\n"
"// Check for a collision between two rects\n"
"fn rectToRect*(r1, r2: rect.Rect): bool {\n"
"//~~\n"
"\treturn umth_coll_rect_to_rect(&r1, &r2)\n"
"}\n"
"\n"
"",
"import(\"image.um\"; \"th.um\")\n"
"\n"
"//~~Placeholder images\n"
"// These images are included with tophat and don\'t have to be loaded.\n"
"var (\n"
"\t// an image useful for testing\n"
"\ttest*: image.Image\n"
"\t// the image used for the app icon\n"
"\ticon*: image.Image\n"
")\n"
"//~~\n"
"\n"
"fn umth_placeholder_fetch(id: uint32): ^struct{}\n"
"\n"
"// **INTERNAL**\n"
"fn __setup*() {\n"
"\ttest = image.Image{umth_placeholder_fetch(0)}\n"
"\ticon = image.Image{umth_placeholder_fetch(1)}\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"canvas.um\"\n"
"\t\"rect.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"//~~struct Mesh\n"
"// Mesh is a 2d array of bool cells.  If a cell is true, the cell can be used\n"
"// in a path.  The mesh is located in a world using the `r` field.  A cell can\n"
"// have an arbitrary size as specified by `s`.\n"
"// \n"
"// The mesh can be edited using the `addQuad` method, but it should be trivial\n"
"// to add your own, similar methods.\n"
"// \n"
"// Please use the `mk` constructor to construct a `Mesh`, unless you really\n"
"// know what you\'re doing.\n"
"type Mesh* = struct {\n"
"\t// The mesh data.\n"
"\td: []bool\n"
"\t// The dimensions and position of the mesh, r.w == w * s\n"
"\tr: rect.Rect\n"
"\t// Width of the mesh.  Used to adress the mesh data.\n"
"\tw: th.uu\n"
"\t// Scale of one cell (cell is a square)\n"
"\ts: th.fu\n"
"}\n"
"//~~\n"
"\n"
"//~~fn mk\n"
"// Creates a new nav mesh. The dimensions must be divisible by the scale.\n"
"// `r`\n"
"// : the rectangle of the mask\n"
"// \'s\'\n"
"// : the scale of the mask\n"
"fn mk*(r: rect.Rect, s: th.fu): Mesh {\n"
"//~~\n"
"\tif r.w % s != 0 || r.h % s != 0 {\n"
"\t\terror(\"The mask dimensions must be divisible by the scale\")\n"
"\t}\n"
"\n"
"\tm := Mesh{}\n"
"\n"
"\tm.d = make([]bool, trunc(r.w/s * r.h/s))\n"
"\tfor i in m.d {\n"
"\t\tm.d[i] = true\n"
"\t}\n"
"\n"
"\tm.w = trunc(r.w/s)\n"
"\tm.s = s\n"
"\tm.r = r\n"
"\n"
"\treturn m\n"
"}\n"
"\n"
"fn umth_nav_mesh_add_quad(m: ^Mesh, q: ^th.Quad)\n"
"//~~fn Mesh.addQuad\n"
"// Sets mask\'s fields overlapping `q` to `false`.\n"
"fn (m: ^Mesh) addQuad*(q: th.Quad) {\n"
"//~~\n"
"\tumth_nav_mesh_add_quad(m, &q)\n"
"}\n"
"\n"
"fn umth_nav_mesh_nav(cameFrom: ^th.Vf2, m: ^Mesh, p1, p2: th.Vf2)\n"
"//~~fn Mesh.nav\n"
"// Navigates between `p1` and `p2`. Returns the path as an array of `th.Vf2`s.\n"
"// If it doesn\'t find any path, or one of the points is outside of the mask,\n"
"// returns an empty array.\n"
"fn (m: ^Mesh) nav*(p1, p2: th.Vf2): []th.Vf2 {\n"
"//~~\n"
"\tcameFrom := make([]th.Vf2, len(m.d))\n"
"\tfor i in cameFrom {\n"
"\t\tcameFrom[i] = th.Vf2{-1, -1}\n"
"\t}\n"
"\n"
"\tumth_nav_mesh_nav(&cameFrom[0], m, p1, p2)\n"
"\t\n"
"\tpath := []th.Vf2{p2}\n"
"\tp := p2\n"
"\tp.x = trunc((p.x - m.r.x) / m.s)\n"
"\tp.y = trunc((p.y - m.r.y) / m.s)\n"
"\n"
"\tp1.x = trunc((p1.x - m.r.x) / m.s)\n"
"\tp1.y = trunc((p1.y - m.r.y) / m.s)\n"
"\tfor (p.x != p1.x || p.y != p1.y) && p.x >= 0 && p.y >= 0 {\n"
"\t\tp = cameFrom[trunc(p.x + p.y*m.w)]\n"
"\n"
"\t\tpath = append(path, th.Vf2{\n"
"\t\t\tp.x * m.s + m.r.x + m.s/2,\n"
"\t\t\tp.y * m.s + m.r.y + m.s/2 })\n"
"\t}\n"
"\n"
"\tfor i:=0; i < len(path)/2; i++ {\n"
"\t\tt := path[i]\n"
"\t\tpath[i] = path[len(path) - i - 1]\n"
"\t\tpath[len(path) - i - 1] = t\n"
"\t}\n"
"\n"
"\t// path not found is the first element is [-1; -1]\n"
"\tif len(path) > 0 && path[0].x < m.r.x {\n"
"\t\treturn []th.Vf2{}\n"
"\t}\n"
"\n"
"\treturn path\n"
"}\n"
"",
};
const char *th_em_modulenames[] = { "anim.um", "audio.um", "csv.um", "ent.um", "image.um", "input.um", "misc.um", "canvas.um", "ray.um", "rect.um", "tilemap.um", "window.um", "ui.um", "std/std.um", "particles.um", "lerp.um", "font.um", "th.um", "signal.um", "atlas.um", "ui/label.um", "ui/grid.um", "ui/imagebox.um", "shader.um", "color.um", "coll.um", "placeholders.um", "nav.um",  };
int th_em_modulenames_count = 28;
const char *th_em_misc[] = {
"BSD 3-Clause License\n"
"\n"
"Copyright (c) 2021, Marek Maskarinec\n"
"All rights reserved.\n"
"\n"
"Redistribution and use in source and binary forms, with or without\n"
"modification, are permitted provided that the following conditions are met:\n"
"\n"
"1. Redistributions of source code must retain the above copyright notice, this\n"
"   list of conditions and the following disclaimer.\n"
"\n"
"2. Redistributions in binary form must reproduce the above copyright notice,\n"
"   this list of conditions and the following disclaimer in the documentation\n"
"   and/or other materials provided with the distribution.\n"
"\n"
"3. Neither the name of the copyright holder nor the names of its\n"
"   contributors may be used to endorse or promote products derived from\n"
"   this software without specific prior written permission.\n"
"\n"
"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n"
"AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n"
"IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n"
"DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n"
"FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n"
"DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n"
"SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n"
"CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n"
"OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
"",
"v0.10\n"
"",
};
static uint32_t th_em_placeholder_data_2[] = {0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0};
static uint32_t th_em_placeholder_data_3[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
th_em_placeholder th_em_placeholders[] = {
{ th_em_placeholder_data_2, { .w = 12, .h = 12 } },
{ th_em_placeholder_data_3, { .w = 69, .h = 69 } },
};
