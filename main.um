import (
	"umka/rawdraw.um"
	"umka/vec.um"
	"umka/tophat.um"
	"umka/input.um"
	"umka/rectangle.um"
	"umka/entity.um"
	"umka/raycast.um"
	"umka/polygon.um"
	"umka/ui.um"
	"umka/image.um"
	"umka/csv.um"
	"umka/tilemap.um"
	"umka/tween.um"
	"umka/light.um"

	"umka/std/std.um"
)

fn readall*(path: str): str {
	f := std.fopen(path, "r")
  const blockSize = 32
  res := ""

  for ok := true; ok {
	  var buff: [blockSize + 1]char
	  ok = std.fread(f, ^[blockSize]char(&buff)) == 1
	  res += str([]char(buff))
  }

	std.fclose(f)
  return res
}

fn main() { 
	cam := rectangle.mk(0, 0, 200, 200)
	tophat.setup("test game", 100, 100)
	var w, h: int32

	r := raycast.mk(0, 0, 20, 0)
	vis := entity.mk(polygon.mk(0, 0, []int32{-1, -1, 1, -1, 1, 1, -1, 1}), tophat.cyan, 0)

	t := tilemap.mk(readall("etc/tilemap-test.csv"), []image.img{image.load("etc/test.png")})

	for true {
		tophat.cycle(&w, &h, 0xffffffff, cam)
		t.draw(cam)

		if input.ispressed(input.KEY_Q) {
			r.r -= round(0.3 * tophat.delta)
		}
		if input.ispressed(input.KEY_E) {
			r.r += round(0.3 * tophat.delta)
		}
		if input.ispressed(input.KEY_W) {
			r.l -= round(0.1 * tophat.delta)
		}
		if input.ispressed(input.KEY_S) {
			r.l += round(0.1 * tophat.delta)
		}

		ex, ey := vec.rotatepoint(r.x, r.y-r.l, r.x, r.y, r.r)
		camx := cam.x-cam.w/2
		camy := cam.y-cam.h/2
		rawdraw.drawline(round(r.x-camx), round(r.y-camy), round(ex-camx), round(ey-camy), 4, tophat.red)


		r.x, r.y = input.getglobalmousepos(cam)
		var ix, iy: int32
		if r.get_tmap_coll(t, &ix, &iy) {
			vis.p.x = ix
			vis.p.y = iy
			printf("%d %d\n", ix, iy)
			vis.draw(cam)
		}
	}
}

fn windowdestroy() {
	printf("destroying window\n")
}
