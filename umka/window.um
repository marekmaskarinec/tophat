
import (
	"audio.um"
	"canvas.um"
	"image.um"
	"placeholders.um"
	"rect.um"
	"signal.um"
	"std.um"
	"th.um"
)

var (
	start, clockOffset: real
	fpsLimit: int = 60
)

//~~Window dimensions
var (
	w*, h*: int32
)
//~~

//~~Viewport size
var wp*: th.Vf2
//~~

//~~signal OnFrame
var onFrame*: signal.Signal
//~~
//~~signal OnDestroy
var onDestroy*: signal.Signal
//~~

fn umth_window_setup(title: str, w, h: int)
fn umth_window_get_dimensions(w, h: ^int32)

fn umth_window_set_viewport(dm: th.Vf2)
//~~fn setViewport
// Sets the dimensions of the viewport. The dimensions are saved in the `wp`
// variable.
// 
// `dm`
// : dimension of the viewport
fn setViewport*(dm: th.Vf2) {
//~~
	wp = dm
	umth_window_set_viewport(dm)
}

fn setIcon*(img: image.Image)

// 0 = other/unknown
// 2 = linux
// 3 = windows
// 4 = macos (unsupported currently)
// 5 = emscripten
fn umth_window_get_platform_id(): int

//~~fn setup
// Sets up the engine and opens a window.
fn setup*(title: str = "tophat game", width: int = 400, height: int32 = 400) {
//~~
	w, h = width, height
	umth_window_setup(title, width, height)

	th.platform = umth_window_get_platform_id()

	audio.__setup()
	placeholders.__setup()

	setIcon(placeholders.icon)

	clockOffset = std.clock() * 1000
	start = std.clock() * 1000

	setViewport(th.Vf2{width, height})
}

//~~fn cycle
// Cycle needs to be called every cycle for the window to work. If the window
// was closed, it returns false.
fn cycle(delta: real) {
//~~
	umth_window_set_viewport(wp)

	th.delta = trunc(delta*1000.0)
	if th.delta == 0 {
		th.delta = 1
	}

	start = std.clock()*1000
	th.time = round(start - clockOffset)

	umth_window_get_dimensions(&w, &h)

	audio.__cycle()
	canvas.drawRect(th.white, rect.mk(0, 0, wp.x, wp.y))
}

fn drawClear() {
	canvas.drawRect(th.black, rect.mk(-4 * wp.x, 0, 4 * wp.x, wp.y))
	canvas.drawRect(th.black, rect.mk(0, -4 * wp.y, wp.x, 4 * wp.y))
	canvas.drawRect(th.black, rect.mk(wp.x, 0, 4 * wp.x, wp.y))
	canvas.drawRect(th.black, rect.mk(0, wp.y, wp.x, 4 * wp.y))
}

fn umth_frame_callback*(delta: real) {
	cycle(delta)
	onFrame.emit(null)
	drawClear()
}

fn umth_destroy_callback*() {
  onDestroy.emit(null)
}

fn umth_window_set_fullscreen(fullscreen: bool)
fn umth_window_get_fullscreen(): bool

//~~fn setFullscreen
// Makes window go full screen
fn setFullscreen*(fullscreen: bool) {
//~~
	umth_window_set_fullscreen(fullscreen)
}

//~~fn isFullscreen
// Returns true if window is fullscreen 
fn isFullscreen*(): bool {
//~~
	return umth_window_get_fullscreen()
}

//~~fn getDims
// Returns dimensions of the window in screen pixels.
fn getDims*(): th.Vf2 {
//~~
	return th.Vf2{w, h}
}

fn umth_window_set_target_fps(fps: int)

//~~fn setTargetFps
// Sets the fps limit.
// 
// `fps`
// : amount of fps the limit should be set to
//	 
fn setTargetFps*(fps: int) {
//~~
	fpsLimit = fps
	umth_window_set_target_fps(fps)
}

fn umth_window_set_dims(dm: th.Vf2)
//~~fn setDims
// Sets the dimensions of the window.
// 
// `dm`
// : the target dimensions in screen pixels
fn setDims*(dm: th.Vf2) {
//~~
	umth_window_set_dims(dm)
}

fn umth_window_set_icon(img: image.Image)
//~~fn setIcon
// Sets the window icon.
fn setIcon*(img: image.Image) {
//~~
	umth_window_set_icon(img)
}

fn umth_window_show_cursor(show: bool)
//~~fn showCursor
// Show or hide the cursor, linux only.
fn showCursor*(show: bool) {
//~~
	umth_window_show_cursor(show)
}

fn umth_window_freeze_cursor(freeze: bool)
//~~fn freezeCursor
// Freezes the cursor in place. `input.getMouseDelta` will still report mouse
// movements.  The cursor will be automatically hidden.
fn freezeCursor*(freeze: bool) {
//~~
	showCursor(freeze)
	umth_window_freeze_cursor(freeze)
}
