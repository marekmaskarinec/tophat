
import (
	"audio.um"
	"canvas.um"
	"image.um"
	"placeholders.um"
	"rect.um"
	"signal.um"
	"std.um"
	"th.um"
)

var (
	start, end, clockOffset: real
	fpsLimit: int = 60
)

//~~Window dimensions
var (
	w*, h*: int32
)
//~~

//~~Viewport size
var wp*: th.Vf2
//~~

//~~signal OnFrame
var onFrame*: signal.Signal
//~~

fn umth_window_setup(title: str, w, h: int)
fn umth_window_get_dimensions(w, h: ^int32)
fn umth_window_swap_buffers()
fn umth_window_handle(): bool
fn umth_window_sleep(ms: int)

fn umth_window_set_viewport(dm: th.Vf2)
//~~fn setViewport
// Sets the dimensions of the viewport. The dimensions are saved in the `wp`
// variable.
// 
// `dm`
// : dimension of the viewport
fn setViewport*(dm: th.Vf2) {
//~~
	wp = dm
	umth_window_set_viewport(dm)
}

//~~fn setup
// Sets up the engine and opens a window.
fn setup*(title: str = "tophat game", width: int = 400, height: int32 = 400) {
//~~
	w, h = width, height
	umth_window_setup(title, width, height)

	if std.getenv("HOME") == "" {
		th.platform = "windows"
	}

	audio.__setup()
	placeholders.__setup()

	clockOffset = std.clock() * 1000
	start = std.clock() * 1000

	setViewport(th.Vf2{width, height})
}

//~~fn cycle
// Cycle needs to be called every cycle for the window to work. If the window
// was closed, it returns false.
fn cycle(delta: real): bool {
//~~
	umth_window_set_viewport(wp)
	/*
	canvas.drawRect(th.black, rect.mk(-4 * wp.x, 0, 4 * wp.x, wp.y))
	canvas.drawRect(th.black, rect.mk(0, -4 * wp.y, wp.x, 4 * wp.y))
	canvas.drawRect(th.black, rect.mk(wp.x, 0, 4 * wp.x, wp.y))
	canvas.drawRect(th.black, rect.mk(0, wp.y, wp.x, 4 * wp.y))
	*/

	th.delta = trunc(delta*1000)
	if th.delta == 0 {
		th.delta = 1
	}

	start = std.clock()*1000
	th.time = round(start - clockOffset)

	running := umth_window_handle()
	umth_window_get_dimensions(&w, &h)

	audio.__cycle()
	return running
}

fn umth_frame_callback*(delta: real) {
	cycle(delta)
	onFrame.emit(null)
}

fn umth_window_begin_scissor(x, y: int, w, h: uint)
fn umth_window_end_scissor()
//~~fn beginScissorRect
// Disable rendering outside of rect `r`
fn beginScissorRect*(r: rect.Rect) {
//~~
	umth_window_begin_scissor(trunc(r.x), trunc(r.y), trunc(r.w), trunc(r.h))
}

//~~fn endScissor
// Stops cropping
fn endScissor*() {
//~~
	umth_window_end_scissor();
}

fn umth_window_set_fullscreen(fullscreen: bool)
fn umth_window_get_fullscreen(): bool

//~~fn setFullscreen
// Makes window go full screen
fn setFullscreen*(fullscreen: bool) {
//~~
	umth_window_set_fullscreen(fullscreen)
}

//~~fn isFullscreen
// Returns true if window is fullscreen 
fn isFullscreen*(): bool {
//~~
	return umth_window_get_fullscreen()
}

//~~fn getDims
// Returns dimensions of the window in screen pixels.
fn getDims*(): th.Vf2 {
//~~
	return th.Vf2{w, h}
}

fn umth_window_set_target_fps(fps: int)

//~~fn setTargetFps
// Sets the fps limit.
// 
// `fps`
// : amount of fps the limit should be set to
//	 
fn setTargetFps*(fps: int) {
//~~
	fpsLimit = fps
	umth_window_set_target_fps(fps)
}

fn umth_window_set_dims(dm: th.Vf2)
//~~fn setDims
// Sets the dimensions of the window, linux only.
// 
// `dm`
// : the target dimensions in screen pixels
fn setDims*(dm: th.Vf2) {
//~~
	umth_window_set_dims(dm)
}

fn umth_window_set_icon(img: image.Image)
//~~fn setIcon
// Sets the window icon, linux only.
fn setIcon*(img: image.Image) {
//~~
	umth_window_set_icon(img)
}

fn umth_window_show_cursor(show: bool)
//~~fn showCursor
// Show or hide the cursor, linux only.
fn showCursor*(show: bool) {
//~~
	umth_window_show_cursor(show)
}

fn umth_window_freeze_cursor(freeze: bool)
//~~fn freezeCursor
// Freezes the cursor in place. `input.getMouseDelta` will still report mouse
// movements. Linux only.
fn freezeCursor*(freeze: bool) {
//~~
	umth_window_freeze_cursor(freeze)
}
