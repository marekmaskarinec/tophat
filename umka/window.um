// Module for interacting with
// the engine.
// Useful variables:
//   delta: length of last cycle
//   platform: either "linux" or "windows"

import (
	"th.um"
	"canvas.um"
	"rect.um"
	"input.um"
	"audio.um"
	"std/std.um"
)

var (
	start, end: uint
	w*, h*: int32
)

fn getTime(): int

// Set's up the engine and opens a window.
fn setup*(title: str, w, h: int32) {
	canvas.setup(title, w, h)
	canvas.setBgColor(0x000000ff)
	canvas.clearframe()

	if std.getenv("HOME") == "" {
		input.setwinmap()
		th.platform = "windows"
	}

	audio.sarr = []audio.Sound{}

	th.time = getTime()
}

// Sets window title on runtime
fn setwindowtitle*(title: str)
fn visualizecam(w, h: int32, color: uint32)
fn updatescaling(w, h, camw, camh: int32)
fn setup(title: str, w, h: int)
fn clearframe()
fn getdimensions(w, h: ^int32)
fn swapbuffers()
fn handleinput()

// Function called each cycle.
// W and H will return the
// window size, bgcolor will
// be the background color
// of the window and cam
// is used for in engine
// stuff.
fn cycle*(cam: rect.Rect) {
	canvas.setColor(0x000000ff)
	canvas.drawRect(rect.Rect{0, cam.h, w, h})
	canvas.drawRect(rect.Rect{cam.w, 0, w, h})
	swapbuffers()

	end = getTime()/1000
	th.delta = (end - start)
	for th.delta < 0 {
		th.delta += 1000
	}
	start = getTime()/1000
	th.time += th.delta

	canvas.setBgColor(0x000000ff)
	clearframe()
	handleinput()
	getdimensions(&w, &h)

	updatescaling(w, h, round(cam.w), round(cam.h))
}

