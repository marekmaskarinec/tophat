// Sound module for audio loading and playing.

import (
	"th.um"
)

// Sound is an opaque pointer to c. Creating it manually will cause a crash.
type Sound* = struct {
	handle: int
}

var sarr*: []Sound

fn setSounds*(ss: []Sound)

fn cauload(path: str): int

fn cauarr(s: ^Sound, count: th.uu)

fn csoundloop(s: int, looping: th.uu)

fn csoundplay(s: int) 

fn csoundstop(s: int)

fn csoundvol(s: int, vol: th.fu)

fn csoundvalidate(s: int): th.uu

// Loads sound at path relative to main.um
fn load*(path: str): Sound {
	s := Sound{cauload(path)}

	sarr = append(sarr, s)
	setSounds(sarr)

	return s
}

// Sets the array of Sounds that are handled in the background. **DEPRECATED**
fn setSounds*(ss: []Sound) {
	cauarr(&ss[0], len(ss))
}

// Sets the Sound as looping. Off by default.
fn (s: ^Sound) looping*(l: bool) {
	if l {
		csoundloop(s.handle, 1)
		return
	}

	csoundloop(s.handle, 0)
}

// Plays the sound. If it is already playing, it won't do anything. Soon this
// behaviour will be changed.
fn (s: ^Sound) play*() {
	csoundplay(s.handle)
}

// Stops the sound and resets the progress.
fn (s: ^Sound) stop*() {
	csoundstop(s.handle)
}

// Set's the volume of the sound as a multiplier of it's default volume.
fn (s: ^Sound) vol*(vol: th.fu) {
	csoundvol(s.handle, vol)
}

// Returns true, if the sound is valid. That doesn't mean, it isn't corrupted,
// but it generally means it was loaded.
fn (s: ^Sound) validate*(): bool {
	return bool(csoundvalidate(s.handle))
}
