// Raycasts allow for vroom fast collisions.

import (
	"th.um"
	"entity.um"
	"polygon.um"
	"tilemap.um"
)

// Ray type.
type ray* = struct {
	pos: th.vf2
	l: th.fu // length
	r: th.fu // rotation
}

var colldatax, colldatay: int32

// Makes a ray. Just for consistency.
fn mk*(pos: th.vf2, l, r: th.fu): ray {
	return ray{pos, l, r}
}

fn craygetcoll(ic: ^th.vf2, count: int32, r: ^ray, s: ^^entity.ent): int32
fn craygettmapcoll(r: ^ray, t: ^tilemap.ctmap, ic: ^th.vf2): bool

// Same as ent.getcoll. Same changes will apply.
fn (r: ^ray) getcoll*(s: []^entity.ent, ic: ^th.vf2): int32 {
	return craygetcoll(ic, len(s), r, &s[0])
}

fn (r: ^ray) gettmapcoll*(t: tilemap.tmap, ic: ^th.vf2): bool {
	ccm := make([]int32, len(t.collmask))
	for i:=0; i < len(t.collmask); i++ {
		ccm[i] = int32(t.collmask[i])
	}

	cm := tilemap.ctmap{^int(&t.tiles[0]), t.pos, t.w, len(t.cells)/t.w, &t.cells[0], &t.collmask[0], t.cellsize, t.scaletype}

	return craygettmapcoll(r, &cm, ic)
}
