//~~
// Canvas library allowing for drawing basic shapes. Coordinates are based on
// the screen.
//~~

import (
	"th.um"
	"rect.um"
)

fn umth_canvas_draw_text(text: str, pos: th.Vf2, color: uint32, size: th.fu)
//~~fn drawText
// Draws a basic pixel text. Only ascii is supported.
fn drawText*(text: str, pos: th.Vf2, color: uint32, size: th.fu) {
//~~
	umth_canvas_draw_text(text, pos, color, size)
}

//~~fn textSize
// Returns the size of text taken by an equivalent drawText call.
fn textSize*(text: str, scale: th.fu): th.Vf2 {
//~~
	var w, maxw, h: int
	w = 0
	maxw = 0
	h = 1
	
	for i in text {
		if text[i] == "\n" {
			h += 1
			if w > maxw {
				maxw = w
			}

			continue
		}

		w++
	}

	if w > maxw {
		maxw = w
	}

	return th.Vf2{maxw * scale * 6 - scale, h * 6 * scale}
}

fn umth_canvas_draw_rect(color: uint32, r: rect.Rect)
//~~fn drawRect
// Draws a Rectangle.
fn drawRect*(color: uint32, r: rect.Rect) {
//~~
	umth_canvas_draw_rect(color, r)
}

fn umth_canvas_draw_line(color: uint32, b, e: th.Vf2, thickness: th.fu)
//~~fn drawLine
// Draws a line.
fn drawLine*(color: uint32, b, e: th.Vf2, thickness: th.fu) {
//~~
	umth_canvas_draw_line(color, b, e, thickness)
}

//~~fn drawRectLines
// Draws rect border.
fn drawRectLines*(color: uint32, r: rect.Rect, thickness: real32 = 1.0) {
//~~
  // top
  drawLine(color, th.Vf2{r.x-1, r.y}, th.Vf2{r.x+r.w, r.y}, thickness)
  // bottom
  drawLine(color, th.Vf2{r.x, r.y+r.h}, th.Vf2{r.x+r.w, r.y+r.h}, thickness)
  // left
  drawLine(color, th.Vf2{r.x, r.y}, th.Vf2{r.x, r.y+r.h}, thickness)
  // right
  drawLine(color, th.Vf2{r.x+r.w, r.y}, th.Vf2{r.x+r.w, r.y+r.h}, thickness)
}

fn umth_canvas_draw_quad(color: uint32, q: ^th.Quad)
//~~fn drawQuad
// Draws a convex quad.
fn drawQuad*(color: uint32, q: th.Quad) {
//~~
	umth_canvas_draw_quad(color, &q)
}

fn umth_canvas_begin_scissor_rect(x, y, w, h: real)
fn umth_canvas_end_scissor()
//~~fn beginScissorRect
// Disable rendering outside of rect `r`
fn beginScissorRect*(r: rect.Rect) {
//~~
	umth_canvas_begin_scissor_rect(r.x, r.y, r.w, r.h)
}

//~~fn endScissor
// Stops cropping
fn endScissor*() {
//~~
	umth_canvas_end_scissor();
}
