// vim: filetype=umka

import "std/std.um"

type poly* = struct {
    x: int32
    y: int32
    v: []int32
		rv: []int32
		rw: int32
		rh: int32
    w: int32
    h: int32
    vc: int32
}

type cpoly* = struct {
	x: int32
	y: int32
	v: ^int32
	w: int32
	h: int32
	vc: int32
}

fn mk*(x, y: int32, v: []int32): poly {
	var p: poly

	p.vc = int32(len(v)/2)
	p.v = v
	p.x = x
	p.y = y

	var maxx, maxy: int32;

	for i:=0; i < len(v); i += 2 {
		if v[i] > maxx { maxx = v[i] }
		
		if v[i + 1] > maxy { maxy = v[i + 1] }
	}

	p.w = maxx
	p.h = maxy
	p.rw = p.w
	p.rh = p.h
	p.rv = v

	return p
}

fn rotatepoint(x, y, cx, cy, rot: int32): (int32, int32) {

	angle := (rot * std.pi) / 180

	x1 := x - cx;
	y1 := y - cy;

	x2 := round(x1 * cos(angle) - y1 * sin(angle));
	y2 := round(x1 * sin(angle) + y1 * cos(angle));

	return x2 + cx, y2 + cy
}

fn (p: ^poly) transform*(sx, sy: real, rot: int32) {
	var x, y, cx, cy: int32

	cx = round(p.w/2 * sx)
	cy = round(p.h/2 * sy)
	
	var w, h: int32

	v := []int32{}

	for i:=0; i<len(p.v); i+=2 {
		x, y = rotatepoint(p.rv[i], p.rv[i+1], cx, cy, rot)

		x = round(x * sx)
		y = round(y * sy)

		if x - p.x > w {
			w = x - p.x
		}
		if y - p.y > h {
			h = y - p.y
		}

		v = append(v, []int32{x, y})
	}

	p.v = v
	p.w = w
	p.h = h
}
