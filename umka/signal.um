// A module for importless communication between modules. A signal is a set of
// callbacks.  You can use signals directly in your own structs if you want
// them to be instance specific, of you can use global signals which are
// adressed by a string name.

// `cctx` is value passed by the caller to `emit`. `uctx` is the value passed
// to the register function.
type Callback* = fn(cctx, uctx: any) 

type User* = struct {
	func: Callback
	uctx: any
}

type Id* = uint
type Signal* = map[Id]User

var signals: map[str]Signal
var idCounter: Id

// `Signal` constructor
fn mk*(): Signal {
	return make(Signal)
}

// Registers a callback to a signal and returns the callback id.
fn (this: ^Signal) register*(callback: Callback, uctx: any): Id {
	idCounter++
	this[idCounter] = User{ callback, uctx }

	return idCounter
}

// Removes a callback by id.
fn (this: ^Signal) remove*(id: Id) {
	delete(this^, id)
}

// Emits a signal.
fn (this: ^Signal) emit*(ctx: any) {
	for c in this {
		this[c].func(ctx, this[c].uctx)
	}
}

// Registers a callback to a global signal.  There is no need to explicitely
// create global signals.  Returns id of the added callback
fn register*(name: str, callback: Callback, uctx: any): Id {
	if !valid(signals) {
		signals = make(map[str]Signal)
	}

	return signals[name].register(callback, uctx)
}

// Removes a callback from a global signal by id.
fn remove*(name: str, id: Id) {
	signals[name].remove(id)
}

// Calls all callbacks associated with the passed global signal name.
fn emit*(name: str, ctx: any) {
	if !valid(signals) {
		signals = make(map[str]Signal)
	}

	signals[name].emit(ctx)
}

