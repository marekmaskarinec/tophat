// Tilemaps allow for easy level construction or fast collisions. You can even
// use them for some games instead of entities (tetris comes to mind)

import (
	"th.um"
	"csv.um"
	"image.um"
	"std.um"
	"rect.um"
	"ent.um"
	"atlas.um"
)

// Tilemap struct
type Tilemap* = struct {
	atlas: atlas.Atlas
	pos: th.Vf2
	w: th.uu // width of tilemap
	cells: []th.uu // all cells (this will draw the tile in tiles with number in cells - 1)
	collMask: []bool // if true, the tile collides
	scale: th.fu
}

type ctmap* = struct {
	atlas: atlas.Atlas
	pos: th.Vf2
	w, h: th.uu
	cells: ^th.uu
	collmask: ^bool
	scale: th.fu
}

fn mk*(cells: []th.uu, w: th.uu, at: atlas.Atlas, scale: th.fu): Tilemap {
	t := Tilemap{}
	t.cells = cells
	t.w = w
	t.atlas = at
	t.collMask = make([]bool, 10) //  TODO
	t.scale = scale
	
	return t
}

fn parseNum(inp: char): (int, bool) {
	if inp >= '0' && inp <= '9' {
		return int(inp) - int('0'), true
	}

	if inp >= 'A' && inp <= 'Z' {
		return int(inp) - int('A'), true
	}

	if inp >= 'a' && inp <= 'z' {
		return int(inp) - int('a'), true
	}

	return 0, false
}

// Makes a tilemap from csv string
fn fromCSV*(inp: str, images: []image.Image): Tilemap {
/*	res := csv.parse(inp)

	if len(res) < 2 { return Tilemap{} }
	if len(res[0]) < 2 { return Tilemap{} }
	if res[0][0] != "tophat tilemap" { return Tilemap{} }

	if len(res[1]) != len(images) {
		error("incorRect collision mask in tilemap")
	}
	collmask := make([]bool, len(res[1]))
	for i:=0; i < len(res[1]); i++ {
		if res[1][i] == "true" { collmask[i] = true; continue }
		collmask[i] = false
	}

	cells := []th.uu{}
	for i:=2; i < len(res); i++ {
		for j:=0; j < len(res[i]); j++ {
			if res[i][j] == "" {
				continue
			}

			val, check := parseNum(res[i][j][0])
			if !check {
				error("number in tilemap isn't valid")
			}

			if val > len(images) {
				error("number on " + repr(i) + ", " + repr(j) + "exceeds number of images")
			}

			cells = append(cells, val)
		}
	}

	return Tilemap{
		images, th.Vf2{std.atoi(res[0][1]), std.atoi(res[0][2])},
		len(res[2]), cells, collmask, std.atoi(res[0][3])}*/
	return Tilemap{}
}

// Sets tile at [x, y] to tile.
fn (t: ^Tilemap) edit*(x, y, tile: int) {
	t.cells[y*t.w + x] = tile
}

fn cdrawtmap(ct: ^ctmap, cam: ^rect.Rect)

// Returns a c represenation of t
fn (t: ^Tilemap) toc*(): ctmap {
	return ctmap{t.atlas, t.pos, t.w, len(t.cells) / t.w, &t.cells[0], &t.collMask[0], t.scale}
}

// Draws the tilemap.
fn (t: ^Tilemap) draw*(cam: rect.Rect) {
	if len(t.cells) == 0 { return }

	cm := t.toc()
	cdrawtmap(&cm, &cam)
}

fn ctmapgetcoll(pos: ^th.Vf2, vert: ^th.uu, t: ^ctmap, e: ^ent.Ent): int32

// Checks, if t collides with e.
// pos is the tile index where the collision happened
// vert is which index collided
// You need to pass a valid pointer (TODO)
fn (t: ^Tilemap) getColl*(e: ent.Ent, vert: ^th.uu, pos: ^th.Vf2): bool {
	if len(t.cells) == 0 { return false }

	cm := t.toc()
	c := ctmapgetcoll(pos, vert, &cm, &e)

	return bool(c)
}
