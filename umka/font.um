// Module for font rendering. Unicode is supported, but only left to right.

import (
	"th.um"
	"std/map.um"
	"std/utf8.um"
	"image.um"
)

// Font type. It is an opaque structure.
type Font* = struct {
	handle: th.uu
}

// A structure built on top of Font. It automatially caches runes used in
// drawing. Thanks to this it's possible to change the text without performance
// problems. There is a known bug with letters like q not being offset properly.
type Cached* = struct {
	runes: map.Map
	size: th.fu
	font: Font
}

fn crenderglyph(font: th.uu, glyph: uint32, scale: th.fu): th.uu

// Renders a white glyph with given size. The glyph is properly positioned
// in relation to the baseline, so it's ready to be drawn at the same height
// as all other glyph images produced by this method.
fn (f: ^Font) renderGlyph*(glyph: uint32, scale: th.fu): image.Image {
	return image.Image{crenderglyph(f.handle, glyph, scale)}
}

fn cfontload(path: str): th.uu

// Loads a font from file.
fn load*(path: str): Font {
	return Font{cfontload(path)}
}

fn getYOff(f: th.uu, r: utf8.Rune): int

// Cached font constructor.
fn mkCached*(f: Font, s: th.fu): Cached {
	return Cached {
		runes: map.Map{},
		size: s,
		font: f}
}

fn (c: ^Cached) preCacheRune(rune: utf8.Rune) {
	if ^image.Image(c.runes.get(rune)) != null {
		return
	}

	c.runes.set(rune, c.font.renderGlyph(rune, c.size))
}

// Precaches all runes inside string s. This can prevent some frame drop on
// the start of the game.
fn (c: ^Cached) preCacheStr*(s: str) {
	runes := utf8.decode(s)
	
	for r in runes {
		if r == uint32(' ') {
			continue
		}

		c.preCacheRune(r)
	}
}

// Draws the text using a Cached font c. Transform roation not supported.
fn (c: ^Cached) draw*(text: str, pos: th.Vf2, color: uint32, scale: th.fu) {
	lx := pos.x
	runes := utf8.decode(text)

	maxH := -1.0
	for r in runes {
		if r == uint32(' ') {
			continue
		}

		if ^image.Image(c.runes.get(r)) == null {
			c.preCacheRune(r)
		}

		if h := ^image.Image(c.runes.get(r)).getDims().y; maxH < 0 || maxH < h {
			maxH = h
		}
	}

	maxH /= 1.5
	for r in runes {
		// line and space handling is bad.
		if r == uint32(' ') {
			dm := ^image.Image(c.runes.get(runes[0])).getDims()
			pos.x += dm.x * scale
			continue
		}

		if r == uint32('\n') {
			dm := ^image.Image(c.runes.get(runes[0])).getDims()
			pos.y += maxH*1.1 * scale
			pos.x = lx
		}

		if ^image.Image(c.runes.get(r)) == null {
			c.preCacheRune(r)
		}

		img := ^image.Image(c.runes.get(r))^
		dm := img.getDims()

		img.draw(th.Transform{p: pos, s: th.Vf2{scale, scale}}, color)

		pos.x += dm.x * scale * 1.1
	}
}

fn (c: ^Cached) runeDims*(rune: utf8.Rune): th.Vf2 {
	img := ^image.Image(c.runes.get(rune))
	if img == null {
		c.preCacheRune(rune)
		img = ^image.Image(c.runes.get(rune))
	}

	return img.getDims()
}

