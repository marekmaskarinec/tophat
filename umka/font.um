// Module for font rendering. Unicode is supported, but only left to right.

import (
	"th.um"
	"std/map.um"
	"std/utf8.um"
	"image.um"
)

// Font type. It is an opaque structure.
type Font* = struct {
	index: th.uu
}

// A structure built on top of Font. It automatially caches runes used in
// drawing. Thanks to this it's possible to change the text without performance
// problems. There is a known bug with letters like q not being offset properly.
type Cached* = struct {
	runes: map.Map
	color: uint32
	size: th.fu
	font: Font
}

fn ctexttoimg(
	t: th.uu, text: ^utf8.Rune,
	runec: th.uu, size: th.fu, color: uint32, spacing: th.Vf2): uint

// Creates an image.img from a text. ax and ay are character/line spacings.
// Not recommended to be used on it's own. Use Cached instead.
fn (t: ^Font) strToImage*(text: str, size: th.fu, color: uint32, spacing: th.Vf2): image.Image {
	runes := utf8.decode(text)
	return image.Image{ctexttoimg(t.index, &runes[0], len(runes), size, color, spacing)}
}

fn cfontload(path: str): th.uu

// Loads a font from file.
fn load*(path: str): Font {
	return Font{cfontload(path)}
}

fn getYOff(f: th.uu, r: utf8.Rune): int

// Cached font constructor.
fn mkCached*(f: Font, c: uint32, s: th.fu): Cached {
	return Cached {
		runes: map.Map{},
		color: c,
		size: s,
		font: f}
}

fn (c: ^Cached) preCacheRune(rune: utf8.Rune) {
	if &c.runes == null {
		c.runes = map.Map{}
	}

	c.runes.set(rune,
		c.font.strToImage(rune.encode(), c.size, 0xffffff00, th.Vf2{0, 0}))
}

// Precaches all runes inside string s. This can prevent some frame drop on
// the start of the game.
fn (c: ^Cached) preCacheStr*(s: str) {
	runes := utf8.decode(s)
	
	for r in runes {
		if r == uint32(' ') {
			continue
		}

		if ^image.Image(c.runes.get(r)) == null {
			c.preCacheRune(r)
		}
	}
}

// Draws the text using a Cached font c. Transform roation not supported.
fn (c: ^Cached) draw*(text: str, t: th.Transform) {
	lx := t.p.x
	runes := utf8.decode(text)

	maxH := -1.0
	for r in runes {
		if r == uint32(' ') {
			continue
		}

		if ^image.Image(c.runes.get(r)) == null {
			c.preCacheRune(r)
		}

		if h := ^image.Image(c.runes.get(r)).getDims().y; maxH < 0 || maxH < h {
			maxH = h
		}
	}

	maxH /= 1.5
	for r in runes {
		// line and space handling is bad.
		if r == uint32(' ') {
			dm := ^image.Image(c.runes.get(runes[0])).getDims()
			t.p.x += dm.x * t.s.x
			continue
		}

		if r == uint32('\n') {
			dm := ^image.Image(c.runes.get(runes[0])).getDims()
			t.p.y += maxH*1.1 * t.s.y
			t.p.x = lx
		}

		if ^image.Image(c.runes.get(r)) == null {
			c.preCacheRune(r)
		}

		img := ^image.Image(c.runes.get(r))^
		dm := img.getDims()
		off := (maxH - dm.y) + (dm.y + getYOff(c.font.index, r) * c.size)
		off *= t.s.y	

		t.p.y += off
		img.draw(t, c.color)
		t.p.y -= off

		t.p.x += dm.x * t.s.x * 1.1
	}
}

