
import (
	"th.um"	
)

//~~struct Rect
// A set of points representing a rectangle.
type Rect* = struct {
	x, y, w, h: th.fu
}
//~~

//~~fn mk
fn mk*(x, y, w, h: th.fu): Rect {
//~~
	var r: Rect

	r.x = x
	r.y = y
	r.w = w
	r.h = h

	return r
}

//~~fn Rect.toWorld
// translates screen coordinates to world coordinates with cam r
fn (r: ^Rect) toWorld*(p: th.Vf2): th.Vf2 {
//~~
	return th.Vf2{ p.x + r.x, p.y + r.y }
}

//~~fn Rect.toScreen
// translates world coordinates to screen coordinates with cam r
fn (r: ^Rect) toScreen*(p: th.Vf2): th.Vf2 {
//~~
	return th.Vf2{ p.x - r.x, p.y - r.y }
}

//~~fn Rect.getPos
fn (r: ^Rect) getPos*(): th.Vf2 {
//~~
	return th.Vf2{r.x, r.y}
}

//~~fn Rect.getDims
fn (r: ^Rect) getDims*(): th.Vf2 {
//~~
	return th.Vf2{r.w, r.h}
}

//~~fn Rect.getEnd
// returns where the second point of the rectangle lies.
fn (r: ^Rect) getEnd*(): th.Vf2 {
//~~
	return th.Vf2{r.x+r.w, r.y+r.h}
}

fn umth_transform_rect(ret: ^th.Quad, r: ^Rect, t: ^th.Transform)
//~~fn Rect.transformed
// Transforms a rect into a quad.
// Order:
// 	1. scale
// 	2. rotation
// 	3. position
fn (r: ^Rect) transformed*(t: th.Transform): th.Quad {
//~~
	var ret: th.Quad
	umth_transform_rect(&ret, r, &t)

	return ret
}

//~~fn Rect.shrink
// Shrink the rectangle by `p` pixels from all sides.
fn (r: ^Rect) shrink*(p: th.Vf2): Rect {
//~~
	return Rect{ r.x + p.x, r.y + p.y, r.w - 2*p.x, r.h - 2*p.y }
}

//~~fn Rect.shift
// Shift the rectangle by `p` pixels.
fn (r: ^Rect) shift*(p: th.Vf2): Rect {
//~~
	return Rect{ r.x + p.x, r.y + p.y, r.w, r.h }
}

//~~fn Rect.scale
// Multiply the dimensions by `p`
fn (r: ^Rect) scale*(p: th.Vf2): Rect {
//~~
	return Rect{ r.x, r.y, r.w * p.x, r.h * p.y }
}
