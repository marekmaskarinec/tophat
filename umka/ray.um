
import (
	"th.um"
	"ent.um"
	"canvas.um"
	"tilemap.um"
)

//~~struct Ray
// Ray is a line specified by an origin, length and a rotation.
type Ray* = struct {
	pos: th.Vf2
	l: th.fu // length
	r: th.fu // rotation
}
//~~

//~~fn mk
// Ray constructor
fn mk*(pos: th.Vf2, l: th.fu, r: th.fu = 0.0): Ray {
//~~
	return Ray{pos, l, r}
}

fn umth_ray_getcoll(colls: ^ent.Coll, count: ^int, maxCount,
	sceneLen: int, r: ^Ray, scene: ^^ent.Ent)
//~~fn Ray.getColl
// Checks the ray's collisions with a scene of ents. Similar to
// `ent.Ent.getColl`
fn (r: ^Ray) getColl*(s: []^ent.Ent, maxColls: th.uu): []ent.Coll {
//~~
	if len(s) == 0 {
		return []ent.Coll{}
	}

	if maxColls > len(s) {
		maxColls = len(s)
	}

	colls := make([]ent.Coll, maxColls)
	count := 0
	umth_ray_getcoll(&colls[0], &count, maxColls, len(s), r, &s[0])
	return slice(colls, 0, count)
}

fn umth_ray_get_tilemap_coll(r: ^Ray, t: ^tilemap.Tilemap, ic: ^th.Vf2): bool
//~~fn Ray.getTilemapColl
// Gets ray's collision to a tilemap.
fn (r: ^Ray) getTilemapColl*(t: tilemap.Tilemap, ic: ^th.Vf2): bool {
//~~
	return umth_ray_get_tilemap_coll(r, &t, ic)
}

//~~fn Ray.getEnd
// Returns the other point of the ray.
fn (r: ^Ray) getEnd*(): th.Vf2 {
//~~
	return r.pos.add(th.Vf2{ 0, r.l }.rotated(th.Vf2{}, r.r))
}

//~~fn Ray.draw
// Draws the ray to the screen.
fn (r: ^Ray) draw*(color: uint32, thickness: th.fu) {
//~~
	canvas.drawLine(color, r.pos, r.getEnd(), thickness)
}
