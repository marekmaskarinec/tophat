
import (
	"th.um"
	"utf8.um"
	"rect.um"
	"font.um"
	"input.um"
	"image.um"
	"canvas.um"
)

const (
	eventUnknown* = 0
	eventHover*
	eventPress*
	eventJustPress*
	eventRelease*
)

// A structure all elements have to contain. t can be set manually by the user,
// s being the dimensions, or it can be set by another elements. onEvent is an
// event callback. It will pass whatever is set in the ctx field.
// Event types:
// eventUnknown
// eventHover
// eventPress
// eventJustPress
// eventRelease
type Generic* = struct {
	t: th.Transform
	gridPos: th.Vf2
	gridSpan: th.Vf2

	ctx: interface{}
	onEvent: fn(eventType: th.uu, ctx: interface{})
	pressed: bool
}

// An interface every ui element has to implements.
type Element* = interface {
	handle()
	draw()
	get(): ^Generic
}

// Interface used anywhere, where text is rendered.
type TextRenderer* = interface {
	draw(text: str, pos: th.Vf2, color: uint32, scale: th.fu)
	runeDims(rune: utf8.Rune): th.Vf2
}

// Bindings around canvas's font rendering functions to make them usable
// with the TextRenderer interface.
type PixelFont* = struct { }
fn (pf: ^PixelFont) draw(text: str, pos: th.Vf2, color: uint32, scale: th.fu) {
	canvas.drawText(text, pos, color, scale)
}
fn (pf: ^PixelFont) runeDims(rune: utf8.Rune): th.Vf2 {
	return th.Vf2{5, 5}
}

// A Grid container. The grid size is fixed, not dynamic like in Tk.
type Grid* = struct {
	g: Generic
	w, h: th.uu
	border: th.fu
	elements: []Element
}

// An element containing an image
type Image* = struct {
	g: Generic
	image: image.Image
	stretch: bool
}

// An element containing a TextRenderer. The text renderer supports
// word-wrapping and centered text.
type Label* = struct {
	g: Generic
	text: str
	renderer: TextRenderer
	center: bool
	wrapping: bool
	color: uint32
	bgColor: uint32
	scale: th.fu
}

fn mkGeneric(): Generic {
	g := Generic{}
	g.onEvent = fn(eventType: th.uu, ctx: interface{}) { }
	return g
}

// Functions that sets the grid pos of a Generic
fn (g: ^Generic) grid*(x, y: th.uu): ^Generic {
	g.gridPos.x = x
	g.gridPos.y = y
	return g
}

// Function setting the grid span of a Generic
fn (g: ^Generic) span*(x, y: th.uu): ^Generic {
	g.gridSpan.x = x
	g.gridSpan.y = y
	return g
}

// Generic's handle function. It checks for events. If you create your own
// ui element and want to have more control over how events are fired, you
// don't have to use it.
fn (g: ^Generic) handle*() {
	m := input.getMousePos()
	if m.x < g.t.p.x || m.y < g.t.p.y ||
		m.x > g.t.p.x + g.t.s.x || m.y > g.t.p.y + g.t.s.y {
		if g.pressed {
			g.pressed = false
			g.onEvent(eventRelease, g.ctx)
		}
		return
	}
	
	g.onEvent(eventHover, g.ctx)
	
	if input.isPressed(input.mouse1) {
		if !g.pressed {
			g.onEvent(eventJustPress, g.ctx)
		}

		g.onEvent(eventPress, g.ctx)
		g.pressed = true
	} else if g.pressed {
		g.pressed = false
		g.onEvent(eventRelease, g.ctx)
	}
}

// Grid's constructor
fn mkGrid*(w, h: th.uu): Grid {
	return Grid {
		g: mkGeneric(),
		w: w, h: h, border: 0,
		elements: []Element{}}
}

fn (g: ^Grid) get*(): ^Generic {
	return &g.g
}

fn (g: ^Grid) handle*() {
	cellSize := th.Vf2{g.g.t.s.x/g.w, g.g.t.s.y/g.h}

	for i:=0; i < len(g.elements); i++ {
		e := &g.elements[i]
		ge := e.get()

		if ge.gridPos.x > g.w || ge.gridPos.y > g.h {
			error("ui.Grid: out of bounds.")
		}

		ge.t.p = ge.gridPos.mul(cellSize)
		// divide by to as there are two borders
		ge.t.p.x += g.border/2 + g.g.t.p.x
		ge.t.p.y += g.border/2 + g.g.t.p.y

		if ge.gridPos.x + ge.gridSpan.x > g.w ||
			ge.gridPos.y + ge.gridSpan.y > g.h {
			error("ui.Grid: out of bounds.")
		}

		if ge.gridSpan.x == 0 {
			ge.gridSpan.x = 1
		}

		if ge.gridSpan.y == 0 {
			ge.gridSpan.y = 1
		}

		ge.t.s = ge.gridSpan.mul(cellSize)
		// don't divide by two as size is relative to position
		ge.t.s.x -= g.border
		ge.t.s.y -= g.border

		e.handle()
	}
}

fn (g: ^Grid) draw*() {
	for e in g.elements {
		e.draw()
	}
}

fn mkImage*(i: image.Image): Image {
	return Image {
		g: Generic{},
		image: i}
}

fn (i: ^Image) get*(): ^Generic {
	return &i.g
}

fn (i: ^Image) handle*() {
	i.g.handle()
}

fn (i: ^Image) draw*() {
	dm := i.image.getDims()
	s := th.Vf2{}
	if i.stretch {
		s.x = i.g.t.s.x/dm.x
		s.y = i.g.t.s.y/dm.y
	} else {
		if i.g.t.s.x < i.g.t.s.y {
			s.x = i.g.t.s.x/dm.x
			s.y = s.x
			i.g.t.p.y += (i.g.t.s.y - s.y*dm.y)/2
		} else {
			s.y = i.g.t.s.y/dm.y
			s.x = s.y
			i.g.t.p.x += (i.g.t.s.x - s.x*dm.x)/2
		}
	}

	i.image.draw(th.Transform{p: i.g.t.p, s: s}, th.white)
}

fn mkLabel*(f: TextRenderer, text: str, color: uint32, scale: th.fu): Label {
	return Label {
		mkGeneric(), text,
		f, false, true, color, 0, scale}
}

fn (l: ^Label) get*(): ^Generic {
	return &l.g
}

fn (l: ^Label) handle*() {
	l.g.handle()
}

fn (l: ^Label) draw*() {
	if len(l.text) == 0 {
		return
	}

	canvas.drawRect(l.bgColor, rect.Rect{l.g.t.p.x, l.g.t.p.y, l.g.t.s.x, l.g.t.s.y})
	text := utf8.decode(l.text)
	lineCount := 1

	if l.wrapping {
		maxW := l.g.t.s.x
		w := 0.0
		wordW := 0.0
		lastSpace := 0
		for i:=0; i < len(text); i++ {
			if text[i] == uint32(' ') {
				lastSpace = i
				step := l.renderer.runeDims(uint32('A')).x * l.scale * 1.1
				w += step
				if wordW > maxW {
					text[i] = uint32('\n')
					w = 0
				}
				wordW = 0
			} else {
				step := l.renderer.runeDims(text[i]).x * l.scale * 1.1
				w += step
				wordW += step
			}

			if text[i] == uint32('\n') {
				w = 0
			}
 
			if w >= maxW && wordW < maxW {
				i = lastSpace
				text[i] = uint32('\n')
				w = 0
				lineCount++
			}
		}
	}

	stext := ""
	w := 0.0
	lineH := -1.0
	origY := l.g.t.p.y
	p := l.g.t.p

	if l.center {
		p.y += (l.g.t.s.y - l.renderer.runeDims(utf8.Rune('A')).y*lineCount*l.scale)/2
	}
	
	for i:=0; true; i++ {
		if i >= len(text) || text[i] == uint32('\n') {
			if l.center {
				p.x = (l.g.t.s.x - w) / 2
			}
			l.renderer.draw(stext, p, l.color, l.scale)

			stext = ""
			p.y += lineH * l.scale * 1.6
			if p.y + lineH*l.scale*1.8 > origY + l.g.t.s.y {
				return
			}
			w = 0
			if i >= len(text) { break }
			continue
		}

		if text[i] == uint32(' ') {
			w += l.renderer.runeDims(uint32('A')).x * l.scale * 1.1
		} else {
			dm := l.renderer.runeDims(text[i]).x
			w += dm * l.scale * 1.1
			if h := dm; lineH == -1 || h > lineH {
				lineH = h
			}
		}

		stext += text[i].encode()
	}
}
