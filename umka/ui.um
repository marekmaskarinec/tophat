// Small and modular ui module useful for stuff like menus.
// Set ui.mainelement to your main element.

import (
	"rectangle.um"
	"rawdraw.um"
	"input.um"
	"tophat.um"
	"image.um"
)

const (
	// text aligns
	MID* = 0
	TOP*
	BOT*

	// image modes
	CENTER* = 0
	STRETCH*
	SCALE*
)

// These are properties every element should have.
type generic* = struct {
	padding: rectangle.rect // amount of space removed from the space available
	
	// position and dimensions. You can set them manually, or use box for automatic
	// placement.
	dimensions: rectangle.rect
	span: int // how many elements in a box it spans
}

// Elements is the interface for all ui elements. You can make your own elements.
type element* = interface {
	draw() // draws the element
	calculate() // calculates it's dimensions
	handle() // handle cycle
	get(): ^generic // returns a pointer to it's generic
}

// Box can be used to oranize
// elements in a v/hbox style or
// to draw image (or both).
// It has children, which are organized
// on it's calculate call.
type box* = struct {
	g: generic
	children: []element
	vertical: bool // false: hbox

	image: image.img
	imagemode: int // CENTER, STRETCH, SCALE
	imgs: int // ignore
	imgx, imgy: int // ignore
}

// Label can be used to draw text.
type label* = struct {
	g: generic
	text: str
	textsize: real
	textcolor: uint32
	valign: int // alignment
	halign: int
	bgcolor: uint32
}

// Button checks for clicks on it's
// handle function. Clicks can be recieved
// the input way, or as callbacks.
type button* = struct {
	label: label // Label (this is what is actually drawn)
	toggled: bool // is toggled
	pressed: bool // is pressed
	justpressed: bool // is just pressed
	justreleased: bool // is just release

	g: generic

	onpress, onjustpress, onrelease: fn() // callbacks
	ontoggle: fn(toggled: bool)
}

////////////////////////////////
// box

fn mkbox*(c: []element, vertical: bool): box {
	h := box {}

	h.g = generic{
		padding: rectangle.rect{},
		dimensions: rectangle.rect{},
		span: 1}
	h.children = c
	h.vertical = vertical
	h.imagemode = CENTER

	return h
}

fn (b: ^box) calculate*() {
	generics := make([]^generic, len(b.children))
	for i:=0; i < len(b.children); i++ {
		generics[i] = b.children[i].get()
	}

	totalspan := 0.0
	off := 0

	for i:=0; i < len(b.children); i++ {
		totalspan += generics[i].span
	}

	for i:=0; i < len(b.children); i++ {
		dims := &generics[i].dimensions
		padd := &generics[i].padding

		if b.vertical {
      
			dims.x = b.g.dimensions.x + off + padd.x
			dims.w = round(real(b.g.dimensions.w)/totalspan) * generics[i].span - padd.w
      
			dims.y = b.g.dimensions.y + padd.y
			dims.h = b.g.dimensions.h - padd.h
      
			b.children[i].calculate()
      
			off += round(real(b.g.dimensions.w)/totalspan) * generics[i].span
		
		} else {
			dims.x = b.g.dimensions.x + padd.x
			dims.w = b.g.dimensions.w - padd.w - padd.x
      
			dims.y = b.g.dimensions.y + off + padd.y
			dims.h = round(real(b.g.dimensions.h)/totalspan * generics[i].span) -
				padd.h - padd.y
      
			b.children[i].calculate()
      
			off += round(real(b.g.dimensions.h)/totalspan) * generics[i].span
		}
	}

	if b.image.handle == 0 {
		return
	}

	switch b.imagemode {
	case CENTER:
		b.imgs = 1

		w, h := b.image.getdims()

		b.imgx = b.g.dimensions.x + (b.g.dimensions.w-w)/2
		b.imgy = b.g.dimensions.y + (b.g.dimensions.h-h)/2
	case SCALE:
		w, h := b.image.getdims()

		sx := b.g.dimensions.w / w
		sy := b.g.dimensions.h / h

		b.imgs = sy

		if sx < sy {
			b.imgs = sx
		}

		b.imgx = b.g.dimensions.x + (b.g.dimensions.w - w*b.imgs)/2
		b.imgy = b.g.dimensions.y + (b.g.dimensions.h - h*b.imgs)/2
	}
}

fn (hb: ^box) draw*() {

	if hb.image.handle != 0 {
		hb.image.draw(hb.imgx, hb.imgy, 0, hb.imgs)
	}

	for i:=0; i < len(hb.children); i++ {
		hb.children[i].draw()
	}
}

fn (b: ^box) get*(): ^generic {
	return &b.g
}

fn (hb: ^box) handle*() {
	for i:=0; i < len(hb.children); i++ {
		hb.children[i].handle()
	}
}

////////////////////////////////
// label

fn mklabel*(text: str, textsize: real, textcolor: uint32): label {
	h := label {}

	h.g = generic{
		padding: rectangle.rect{},
		dimensions: rectangle.rect{},
		span: 1}

	h.text = text
	h.textsize = textsize
	h.textcolor = textcolor
	h.bgcolor = 0x0
	h.valign = MID
	h.halign = MID

	return h
}

fn (l: ^label) calculate*() {
	sx, sy := rawdraw.textsize(l.text, l.textsize)

	switch l.valign {
	case MID:
		l.g.padding.y = (l.g.dimensions.h-sy)/2
	case BOT:
		l.g.padding.y = l.g.dimensions.h - sy
	}

	switch l.halign {
	case MID:
		l.g.padding.x = (l.g.dimensions.w-sx)/2
	case BOT:
		l.g.padding.x = l.g.dimensions.w - sx
	}
}

fn (l: ^label) draw*() {
	rawdraw.setcolor(l.bgcolor)
	rawdraw.drawrect(
		l.g.dimensions.x - l.g.padding.x,
		l.g.dimensions.y - l.g.padding.y,
		l.g.dimensions.w + l.g.padding.w,
		l.g.dimensions.h + l.g.padding.h)

	rawdraw.drawtext(
		l.text, l.g.dimensions.x, l.g.dimensions.y, l.textcolor, l.textsize)
}

fn (l: ^label) get*(): ^generic {
	return &l.g
}

fn (l: ^label) handle*() {}

////////////////////////////////
// button

fn mkbutton*(l: label): button {
	b := button{}

	b.g = generic{
		padding: l.g.padding,
		dimensions: rectangle.rect{},
		span: 1}

	b.label = l
	b.pressed = false
	b.justpressed = false
	b.toggled = false

	b.onpress = fn() {}
	b.onjustpress = fn() {}
	b.onrelease = fn() {}
	b.ontoggle = fn(toggled: bool) {}

	return b
}

fn (b: ^button) calculate*() {
	b.label.g.dimensions = b.g.dimensions
	b.label.calculate()
	b.label.g.dimensions.x += b.label.g.padding.x
	b.label.g.dimensions.w -= b.label.g.padding.w

	b.label.g.dimensions.y += b.label.g.padding.y
	b.label.g.dimensions.h -= b.label.g.padding.h
}

fn (b: ^button) draw*() {
	b.label.draw()
}

fn (b: ^button) get*(): ^generic {
	return &b.g
}

fn (b: ^button) handle*() {
	mx, my := input.getmousepos()
	mp := input.ispressed(input.LMB)

	ms := (
		b.g.dimensions.x <= mx &&
		b.g.dimensions.y <= my &&
		mx <= b.g.dimensions.x + b.g.dimensions.w &&
		my <= b.g.dimensions.y + b.g.dimensions.h)

	b.justpressed = false
	b.justreleased = false 

	if ms && mp {
		if !b.pressed {
			b.justpressed = true
			b.onjustpress()
		}
		b.pressed = true
		b.onpress()
	} else {
		if b.pressed {
			b.justreleased = true
			b.onrelease()
		}
		b.pressed = false
	}

	if b.justpressed {
		b.toggled = !b.toggled
		b.ontoggle(b.toggled)
	}
}

////////////////////////////////
// main handler
// doing it like this is stupid.

var mainelement*: element

// no need to call this
fn update(w, h: int32) {
	dims := &mainelement.get().dimensions
	padd := &mainelement.get().padding
	dims.x = padd.x
	dims.y = padd.y
	dims.w = w - padd.w - padd.x
	dims.h = h - padd.h - padd.y
	mainelement.calculate()
}

// Call this every loop.
fn handle*(w, h: int32) {
	if tophat.t % 100 < 32 {
		update(w, h)
	}

	mainelement.handle()
	mainelement.draw()
}
