// Small and modular ui module useful for stuff like menus.
// Set ui.mainelement to your main element.

import (
	"th.um"
	"rectangle.um"
	"rawdraw.um"
	"input.um"
	"tophat.um"
	"image.um"
)

const (
	// text aligns
	MID* = 0
	TOP*
	BOT*

	// image modes
	CENTER* = 0
	STRETCH*
	SCALE*
)

// These are properties every element should have.
type generic* = struct {
	padding: rectangle.rect // amount of space removed from the space available
	
	// position and dimensions. You can set them manually, or use box for automatic
	// placement.
	dimensions: rectangle.rect
	span: int // how many elements in a box it spans
}

// Elements is the interface for all ui elements. You can make your own elements.
type element* = interface {
	draw() // draws the element
	calculate() // calculates it's dimensions
	handle() // handle cycle
	get(): ^generic // returns a pointer to it's generic
}

// Box can be used to oranize
// elements in a v/hbox style or
// to draw image (or both).
// It has children, which are organized
// on it's calculate call.
type box* = struct {
	g: generic
	children: []element
	vertical: bool // false: hbox

	image: image.img
	imagemode: th.uu // CENTER, STRETCH, SCALE
	imgs: th.fu // ignore
	imgpos: th.vf2 // ignore
}

// Label can be used to draw text.
type label* = struct {
	g: generic
	text: str
	textsize: real
	textcolor: uint32
	align: th.vf2
	bgcolor: uint32

	off: th.vf2
}

// Button checks for clicks on it's
// handle function. Clicks can be recieved
// the input way, or as callbacks.
type button* = struct {
	label: label // Label (this is what is actually drawn)
	toggled: bool // is toggled
	pressed: bool // is pressed
	justpressed: bool // is just pressed
	justreleased: bool // is just release

	g: generic

	onpress, onjustpress, onrelease: fn() // callbacks
	ontoggle: fn(toggled: bool)
}

////////////////////////////////
// box

fn mkbox*(c: []element, vertical: bool): box {
	h := box {}

	h.g = generic{
		padding: rectangle.rect{},
		dimensions: rectangle.rect{},
		span: 1}
	h.children = c
	h.vertical = vertical
	h.imagemode = CENTER

	return h
}

fn (b: ^box) calculate*() {
	generics := make([]^generic, len(b.children))
	for i:=0; i < len(b.children); i++ {
		generics[i] = b.children[i].get()
	}

	totalspan := 0.0
	off := 0

	for i:=0; i < len(b.children); i++ {
		totalspan += generics[i].span
	}

	for i:=0; i < len(b.children); i++ {
		dims := &generics[i].dimensions
		padd := &generics[i].padding

		if b.vertical {
			dims.x = b.g.dimensions.x + off + padd.x
			dims.w = trunc(real(b.g.dimensions.w)/totalspan) * generics[i].span - padd.w

			dims.y = b.g.dimensions.y + padd.y
			dims.h = b.g.dimensions.h - padd.h
      
			b.children[i].calculate()
      
			off += trunc(real(b.g.dimensions.w)/totalspan) * generics[i].span
		} else {
			dims.x = b.g.dimensions.x + padd.x
			dims.w = b.g.dimensions.w - padd.w - padd.x
      
			dims.y = b.g.dimensions.y + off + padd.y
			dims.h = trunc(real(b.g.dimensions.h)/totalspan * generics[i].span) -
				padd.h - padd.y
      
			b.children[i].calculate()
      
			off += trunc(real(b.g.dimensions.h)/totalspan) * generics[i].span
		}
	}

	if b.image.handle == 0 {
		return
	}

	dm := b.image.getdims()
	switch b.imagemode {
	case CENTER:
		b.imgs = 1


		b.imgpos.x = round(b.g.dimensions.x + (b.g.dimensions.w-dm.x)/2)
		b.imgpos.y = round(b.g.dimensions.y + (b.g.dimensions.h-dm.y)/2)
	case SCALE:
		sx := round(b.g.dimensions.w / dm.x)
		sy := round(b.g.dimensions.h / dm.y)

		b.imgs = sy

		if sx < sy {
			b.imgs = sx
		}

		b.imgpos.x = round(b.g.dimensions.x + (b.g.dimensions.w - dm.x*b.imgs)/2)
		b.imgpos.y = round(b.g.dimensions.y + (b.g.dimensions.h - dm.y*b.imgs)/2)
	}
}

fn (hb: ^box) draw*() {

	if hb.image.handle != 0 {
		hb.image.draw(th.vf2{hb.imgpos.x, hb.imgpos.y}, 0, th.vf2{hb.imgs, hb.imgs})
	}

	for i:=0; i < len(hb.children); i++ {
		hb.children[i].draw()
	}
}

fn (b: ^box) get*(): ^generic {
	return &b.g
}

fn (hb: ^box) handle*() {
	for i:=0; i < len(hb.children); i++ {
		hb.children[i].handle()
	}
}

////////////////////////////////
// label

fn mklabel*(text: str, textsize: real, textcolor: uint32): label {
	h := label {}

	h.g = generic{
		padding: rectangle.rect{},
		dimensions: rectangle.rect{},
		span: 1}

	h.text = text
	h.textsize = textsize
	h.textcolor = textcolor
	h.bgcolor = 0x0
	h.align = th.vf2{MID, MID}

	return h
}

fn (l: ^label) calculate*() {
	sx, sy := rawdraw.textsize(l.text, l.textsize)

	switch round(l.align.y) {
	case MID:
		l.off.y = (l.g.dimensions.h - sy - l.g.padding.h)/2
	case BOT:
		l.off.y = l.g.dimensions.h - sy - l.g.padding.h
	}

	switch round(l.align.x) {
	case MID:
		l.off.x = (l.g.dimensions.w - sx - l.g.padding.w)/2
	case BOT:
		l.off.x = l.g.dimensions.w - sx - l.g.padding.w
	}
}

fn (l: ^label) draw*() {
	rawdraw.setcolor(l.bgcolor)
	rawdraw.drawrect(rectangle.rect{
		round(l.g.dimensions.x - l.off.x + l.g.padding.x),
		round(l.g.dimensions.y - l.off.y + l.g.padding.y),
		round(l.g.dimensions.w - l.g.padding.w),
		round(l.g.dimensions.h - l.g.padding.h)})

	rawdraw.drawtext(
		l.text, th.vf2{l.g.dimensions.x, l.g.dimensions.y}, l.textcolor, l.textsize)
}

fn (l: ^label) get*(): ^generic {
	return &l.g
}

fn (l: ^label) handle*() {}

////////////////////////////////
// button

fn mkbutton*(l: label): button {
	b := button{}

	b.g = generic{
		padding: l.g.padding,
		dimensions: rectangle.rect{},
		span: 1}

	b.label = l
	b.pressed = false
	b.justpressed = false
	b.toggled = false

	b.onpress = fn() {}
	b.onjustpress = fn() {}
	b.onrelease = fn() {}
	b.ontoggle = fn(toggled: bool) {}

	return b
}

fn (b: ^button) calculate*() {
	b.label.g.dimensions = b.g.dimensions
	b.label.calculate()
	b.label.g.dimensions.x += round(b.label.off.x) + b.label.g.padding.x
	b.label.g.dimensions.w -= round(b.label.off.y) + b.label.g.padding.y

	b.label.g.dimensions.y += b.label.g.padding.w
	b.label.g.dimensions.h -= b.label.g.padding.h
}

fn (b: ^button) draw*() {
	b.label.draw()
}

fn (b: ^button) get*(): ^generic {
	return &b.g
}

fn (b: ^button) handle*() {
	mx, my := input.getmousepos()
	mp := input.ispressed(input.LMB)

	ms := (
		b.g.dimensions.x <= mx &&
		b.g.dimensions.y <= my &&
		mx <= b.g.dimensions.x + b.g.dimensions.w &&
		my <= b.g.dimensions.y + b.g.dimensions.h)

	b.justpressed = false
	b.justreleased = false 

	if ms && mp {
		if !b.pressed {
			b.justpressed = true
			b.onjustpress()
		}
		b.pressed = true
		b.onpress()
	} else {
		if b.pressed {
			b.justreleased = true
			b.onrelease()
		}
		b.pressed = false
	}

	if b.justpressed {
		b.toggled = !b.toggled
		b.ontoggle(b.toggled)
	}
}

////////////////////////////////
// main handler
// doing it like this is stupid.

var mainelement*: element

// no need to call this
fn update(w, h: int32) {
	dims := &mainelement.get().dimensions
	padd := &mainelement.get().padding
	dims.x = padd.x
	dims.y = padd.y
	dims.w = w - padd.w - padd.x
	dims.h = h - padd.h - padd.y
	mainelement.calculate()
}

// Call this every loop.
fn handle*(w, h: int32) {
	if tophat.t % 100 < 32 {
		update(w, h)
	}

	mainelement.handle()
	mainelement.draw()
}
