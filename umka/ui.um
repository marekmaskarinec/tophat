
import (
	"canvas.um"
	"coll.um"
	"font.um"
	"input.um"
	"rect.um"
	"th.um"
)

type Style* = struct {
	ft: font.Font
	ftScale: th.fu

	backgroundColor: uint32
	textColor: uint32
	primaryColor: uint32
}

type Container* = interface {
	pushRect(r: rect.Rect): rect.Rect
	getDims(): rect.Rect
}

//~~struct Gui
type Gui* = struct {
	ctx: any
	scale: th.fu

	selection: int
	// contains more unexported fields
//~~
	idx: int

	isEval: bool
	style: []Style
	container: []Container
}

type LayoutFn* = fn(gui: ^Gui)

fn (this: ^Gui) pushStyle*(s: Style) {
	this.style = append(this.style, s)
}

fn (this: ^Gui) popStyle*() {
	if len(this.style) > 1 {
		this.style = slice(this.style, 0, len(this.style) - 1)
	}
}

fn (this: ^Gui) getStyle*(): Style {
	return this.style[len(this.style) - 1]
}

fn (this: ^Gui) pushContainer*(c: Container) {
	this.container = append(this.container, c)
}

fn (this: ^Gui) popContainer*() {
	if len(this.container) > 1 {
		this.container =
			slice(this.container, 0, len(this.container) - 1)
	}
}

fn (this: ^Gui) getContainer*(): Container {
	return this.container[len(this.container) - 1]
}

fn (this: ^Gui) pushRect*(r: rect.Rect): rect.Rect {
	return this.getContainer().pushRect(r)
}

fn (this: ^Gui) getDims*(): rect.Rect {
	return this.getContainer().getDims()
}

fn (this: ^Gui) rectToScreen(r: rect.Rect): rect.Rect {
	return rect.fromVf2(r.getPos().mulf(this.scale),
		r.getDims().mulf(this.scale))
}

fn (this: ^Gui) hover(r: rect.Rect): bool {
	return coll.vf2ToRect(input.getMousePos(), r)
}

fn (this: ^Gui) eval*(layout: LayoutFn) {
	this.idx = 0
	this.isEval = true
	layout(this)
}

fn (this: ^Gui) draw*(layout: LayoutFn) {
	this.idx = 0
	this.isEval = false
	layout(this)
}

type BoxGrow = uint
const (
	BoxGrowDimension*   = BoxGrow(0)
	BoxGrowSubdivision* = BoxGrow(1)
)

type BoxDirection = uint
const (
	BoxDirectionDown*  = BoxDirection(0)
	BoxDirectionRight* = BoxDirection(1)
	BoxDirectionUp*    = BoxDirection(2)
	BoxDirectionLeft*  = BoxDirection(3)
)

type BoxConfig* = struct {
	dimension: th.fu
	subdivisions: uint
	growType: BoxGrow
	dir: BoxDirection
}

type Box* = struct {
	grow: th.fu
	dm: rect.Rect
	cfg: BoxConfig
}

fn (this: ^Box) pushRect(r: rect.Rect): rect.Rect {
	switch this.cfg.dir {
	case BoxDirectionDown:
		r.x = this.dm.x
		r.y = this.dm.y

		if r.h == 0 {
			r.h = this.grow
		}

		if r.w == 0 {
			r.w = this.dm.w
		}

		this.dm.y += r.h
	case BoxDirectionRight:
		r.x = this.dm.x
		r.y = this.dm.y

		if r.h == 0 {
			r.h = this.dm.h
		}

		if r.w == 0 {
			r.w = this.grow
		}

		this.dm.x += r.w
	case BoxDirectionUp:
		if r.h == 0 {
			r.h = this.grow
		}

		if r.w == 0 {
			r.w = this.dm.w
		}

		this.dm.h -= r.h
		r.x = this.dm.x
		r.y = this.dm.y + this.dm.h
	case BoxDirectionLeft:
		if r.h == 0 {
			r.h = this.dm.h
		}

		if r.w == 0 {
			r.w = this.grow
		}

		this.dm.w -= r.w
		r.x = this.dm.x + this.dm.w
		r.y = this.dm.y
	}

	return r
}

fn (this: ^Box) getDims(): rect.Rect {
	return this.dm
}

fn (gui: ^Gui) box*(cfg: BoxConfig = BoxConfig{
	dimension: 30,
	growType: BoxGrowDimension,
	dir: BoxDirectionDown }) {

	b := Box{}
	b.dm = gui.pushRect(rect.Rect{})
	b.cfg = cfg
	switch cfg.growType {
	case BoxGrowDimension:
		b.grow = cfg.dimension
	case BoxGrowSubdivision:
		if cfg.subdivisions == 0 {
			error("Invalid subdivision count")
		}

		dm := b.dm.h
		if cfg.dir == BoxDirectionRight || cfg.dir == BoxDirectionLeft {
			dm = b.dm.w
		}

		b.grow = dm / cfg.subdivisions
	}

	gui.pushContainer(b)
}

type StackConfig* = struct { }

type Stack* = struct {
	dm: rect.Rect
	cfg: StackConfig
}

fn (this: ^Stack) pushRect(r: rect.Rect): rect.Rect {
	if r.x == 0 { r.x = this.dm.x }
	if r.y == 0 { r.y = this.dm.y }
	if r.w == 0 { r.w = this.dm.w }
	if r.h == 0 { r.h = this.dm.h }

	return r
}

fn (this: ^Stack) getDims(): rect.Rect {
	return this.dm
}

fn (gui: ^Gui) stack*(cfg: StackConfig = StackConfig{}) {
	gui.pushContainer(Stack{
		dm: gui.pushRect(rect.Rect{}),
		cfg: cfg })
}

type ButtonConfig* = struct {}

fn (gui: ^Gui) button*(cfg: ButtonConfig = ButtonConfig{}): bool {
	gui.stack()
	r := gui.getContainer().getDims()

	if gui.isEval {
		if gui.hover(r) && input.isJustReleased(input.mouse1) {
			return true
		}
		return false
	} else {
		canvas.drawRectLines(gui.getStyle().primaryColor, gui.rectToScreen(r), gui.scale);
	}

	return false
}

type LabelConfig* = struct {
	centerX: bool
	centerY: bool
	stretchX: bool
	stretchY: bool
}

fn (gui: ^Gui) label*(text: str, cfg: LabelConfig = LabelConfig{
	stretchX: true,
	stretchY: true }) {

	if gui.isEval { return }

	if cfg.centerX { cfg.stretchX = true }
	if cfg.centerY { cfg.stretchY = true }

	style := gui.getStyle()
	txtSize := style.ft.measure(text).mulf(style.ftScale * gui.scale)
	r := rect.fromVf2(th.Vf2{}, txtSize)
	if cfg.stretchX { r.w = 0 }
	if cfg.stretchY { r.h = 0 }
	r = gui.pushRect(r)

	x := r.x
	y := r.y
	if cfg.centerX {
		x += (r.w-txtSize.x)/2.0
	}
	if cfg.centerY {
		y += (r.h-txtSize.y)/2.0
	}

	style.ft.draw(text, th.Vf2{x, y}.mulf(gui.scale),
		style.textColor, style.ftScale * gui.scale)
}

fn (gui: ^Gui) qbutton*(text: str, cfg: ButtonConfig = ButtonConfig{}): bool {
	pressed := gui.button()
	gui.label(text, LabelConfig{centerX: true, centerY: true})
	gui.popContainer()
	return pressed;
}

type TextBoxConfig* = struct {}

type TextBox* = struct {
	buffer: str
	cursor: int
}

fn (gui: ^Gui) textBox*(tb: ^TextBox, cfg: TextBoxConfig = TextBoxConfig{}) {
	gui.idx++

	r := gui.pushRect(rect.Rect{})

	hover := gui.hover(r)

	if gui.isEval {
		if input.isJustPressed(input.mouse1) && hover {
			gui.selection = gui.idx
		}

		if input.isJustPressed(input.mouse1) && !hover &&
			gui.selection == gui.idx {
				gui.selection = 0
		}

		if gui.selection != gui.idx {
			return
		}

		if input.isJustPressed(input.key_left) {
			if tb.cursor > 0 { tb.cursor-- }
		}

		if input.isJustPressed(input.key_right) {
			if tb.cursor < len(tb.buffer) { tb.cursor++ }
		}

		if input.isJustPressed(input.key_backspace) {
			if tb.cursor > 0 {
				tb.buffer = slice(tb.buffer, 0, tb.cursor - 1) +
					slice(tb.buffer, tb.cursor)
				tb.cursor--
			}
		}

		s := input.getStr()
		v := true
		for i in s {
			if int(s[i]) < int(' ') || int(s[i]) == int('z') + 1 {
				v = false
			}
		}
		if len(s) > 0 && v {
			tb.buffer = slice(tb.buffer, 0, tb.cursor) + s +
				slice(tb.buffer, tb.cursor)
			tb.cursor += len(s)
		}

		return
	}


	style := gui.getStyle()

	r = gui.rectToScreen(r)
	canvas.drawRectLines(style.primaryColor, r, gui.scale)
	canvas.beginScissorRect(r)

	dm := style.ft.measure(tb.buffer).mulf(gui.scale).mulf(style.ftScale)

	p := th.Vf2{}
	p.y = r.y + r.h/2 - dm.y/2
	c := th.Vf2{}
	c.y = p.y

	cdmx := style.ft.measure(slice(tb.buffer, 0, tb.cursor)).x *
		gui.scale*style.ftScale
	if cdmx < r.w - 2*gui.scale {
		p.x = r.x + gui.scale
		c.x = p.x + cdmx
	} else {
		c.x = r.x + r.w - gui.scale
		p.x = c.x - cdmx
	}

	style.ft.draw(tb.buffer, p, style.textColor, gui.scale * style.ftScale)
	if gui.selection == gui.idx && th.time/500 % 2 == 0 {
		canvas.drawRect(style.textColor,
			rect.mk(c.x, c.y, 1*gui.scale, dm.y))
	}

	canvas.endScissor()
}

fn mk*(r: rect.Rect): Gui {
	gui := Gui{}
	gui.scale = 1
	gui.pushStyle(Style{
		ft: font.load("etc/roboto.ttf", 64),
		ftScale: 0.1,
		backgroundColor: 0xccccccff,
		textColor: 0x000000ff,
		primaryColor: th.blue })
	gui.container = []Container{ Stack{ dm: r } }

	return gui
}
