
import (
	"th.um"
	"vec.um"	
	"utf8.um"
	"rect.um"
	"font.um"
	"input.um"
	"image.um"
	"canvas.um"
)

const (
	eventHover* = 0
	eventPress*
	eventJustPress*
	eventRelease*
)

type Generic* = struct {
	t: th.Transform
	gridPos: th.Vf2
	gridSpan: th.Vf2

	ctx: interface{}
	onEvent: fn(eventType: th.uu, ctx: interface{})
	pressed: bool
}

type Element* = interface {
	handle()
	draw()
	get(): ^Generic
}

type Grid* = struct {
	g: Generic
	w, h: th.uu
	border: th.fu
	elements: []Element
}

type SimpleLabel* = struct {
	g: Generic
	text: str
	textSize: th.fu
	color: uint32
	bgColor: uint32
	center: bool
}

type Image* = struct {
	g: Generic
	image: image.Image
	stretch: bool
}

type Label* = struct {
	g: Generic
	text: str
	font: font.Cached
	center: bool
	wrapping: bool
	bgColor: uint32
	scale: th.fu
}

fn mkGeneric(): Generic {
	g := Generic{}
	g.onEvent = fn(eventType: th.uu, ctx: interface{}) { }
	return g
}

fn (g: ^Generic) grid*(x, y: th.uu): ^Generic {
	g.gridPos.x = x
	g.gridPos.y = y
	return g
}

fn (g: ^Generic) span*(x, y: th.uu): ^Generic {
	g.gridSpan.x = x
	g.gridSpan.y = y
	return g
}

fn (g: ^Generic) handle*() {
	m := input.getMousePos()
	if m.x < g.t.p.x || m.y < g.t.p.y ||
		m.x > g.t.p.x + g.t.s.x || m.y > g.t.p.y + g.t.s.y {
		if g.pressed {
			g.pressed = false
			g.onEvent(eventRelease, g.ctx)
		}
		return
	}
	
	g.onEvent(eventHover, g.ctx)
	
	if input.isPressed(input.LMB) {
		if !g.pressed {
			g.onEvent(eventJustPress, g.ctx)
		}

		g.onEvent(eventPress, g.ctx)
		g.pressed = true
	} else if g.pressed {
		g.pressed = false
		g.onEvent(eventRelease, g.ctx)
	}
}

fn mkGrid*(w, h: th.uu): Grid {
	return Grid {
		g: mkGeneric(),
		w: w, h: h, border: 0,
		elements: []Element{}}
}

fn (g: ^Grid) get*(): ^Generic {
	return &g.g
}

fn (g: ^Grid) handle*() {
	cellSize := th.Vf2{g.g.t.s.x/g.w, g.g.t.s.y/g.h}

	for i:=0; i < len(g.elements); i++ {
		e := &g.elements[i]
		ge := e.get()

		if ge.gridPos.x > g.w || ge.gridPos.y > g.h {
			error("ui.Grid: out of bounds.")
		}

		ge.t.p = vec.mul(ge.gridPos, cellSize)
		// divide by to as there are two borders
		ge.t.p.x += g.border/2
		ge.t.p.y += g.border/2

		if ge.gridPos.x + ge.gridSpan.x > g.w ||
			ge.gridPos.y + ge.gridSpan.y > g.h {
			error("ui.Grid: out of bounds.")
		}

		if ge.gridSpan.x == 0 {
			ge.gridSpan.x = 1
		}

		if ge.gridSpan.y == 0 {
			ge.gridSpan.y = 1
		}

		ge.t.s = vec.mul(ge.gridSpan, cellSize)
		// don't divide by two as size is relative to position
		ge.t.s.x -= g.border
		ge.t.s.y -= g.border

		e.handle()
	}
}

fn (g: ^Grid) draw*() {
	for e in g.elements {
		e.draw()
	}
}

fn mkSimpleLabel*(text: str, color: uint32, size: th.fu): SimpleLabel {
	return SimpleLabel {
		g: mkGeneric(),
		text: text,
		textSize: size,
		color: color}
}

fn (l: ^SimpleLabel) get*(): ^Generic {
	return &l.g
}

fn (l: ^SimpleLabel) handle*() {
	l.g.handle()
}

fn (l: ^SimpleLabel) draw*() {
	canvas.setColor(l.bgColor)

	pos := l.g.t.p
	if l.center {
		dm := canvas.textSize(l.text, l.textSize)
		pos.x += (l.g.t.s.x - dm.x)/2
		pos.y += (l.g.t.s.y - dm.y)/2
	}

	canvas.drawRect(rect.Rect{l.g.t.p.x, l.g.t.p.y, l.g.t.s.x, l.g.t.s.y})
	canvas.drawText(l.text, pos, l.color, l.textSize)
}

fn mkImage*(i: image.Image): Image {
	return Image {
		g: Generic{},
		image: i}
}

fn (i: ^Image) get*(): ^Generic {
	return &i.g
}

fn (i: ^Image) handle*() {
	i.g.handle()
}

fn (i: ^Image) draw*() {
	dm := i.image.getDims()
	s := th.Vf2{}
	if i.stretch {
		s.x = i.g.t.s.x/dm.x
		s.y = i.g.t.s.y/dm.y
	} else {
		if i.g.t.s.x < i.g.t.s.y {
			s.x = i.g.t.s.x/dm.x
			s.y = s.x
			i.g.t.p.y += (i.g.t.s.y - s.y*dm.y)/2
		} else {
			s.y = i.g.t.s.y/dm.y
			s.x = s.y
			i.g.t.p.x += (i.g.t.s.x - s.x*dm.x)/2
		}
	}

	i.image.draw(th.Transform{p: i.g.t.p, s: s})
}

fn mkLabel*(f: font.Cached, text: str, scale: th.fu): Label {
	return Label {
		mkGeneric(), text,
		f, false, true, 0, scale}
}

fn (l: ^Label) get*(): ^Generic {
	return &l.g
}

fn (l: ^Label) handle*() {  }

fn (l: ^Label) draw*() {
	if len(l.text) == 0 {
		return
	}

	canvas.setColor(l.bgColor)
	canvas.drawRect(rect.Rect{l.g.t.p.x, l.g.t.p.y, l.g.t.s.x, l.g.t.s.y})

	l.font.preCacheStr(l.text) 
	text := utf8.decode(l.text)

	if l.wrapping {
		maxW := l.g.t.s.x
		w := 0.0
		wordW := 0.0
		lastSpace := 0
		for i:=0; i < len(text); i++ {
			if text[i] == uint32(' ') {
				lastSpace = i
				step := ^image.Image(l.font.runes.get(text[0])).getDims().x * l.scale * 1.1
				w += step
				if wordW > maxW {
					text[i] = uint32('\n')
					w = 0
				}
				wordW = 0
			} else {
				step := ^image.Image(l.font.runes.get(text[i])).getDims().x * l.scale * 1.1
				w += step
				wordW += step
			}

			if text[i] == uint32('\n') {
				w = 0
			}
 
			if w > maxW && wordW < maxW {
				i = lastSpace
				text[i] = uint32('\n')
				w = 0
			}
		}
	}

	stext := ""
	w := 0.0
	lineH := -1.0
	origY := l.g.t.p.y
	for i:=0; i < len(text); i++ {
		if text[i] == uint32('\n') || i == len(text)-1 {
			if l.center {
				l.g.t.p.x = (l.g.t.s.x - w) / 2
			}
			l.font.draw(stext, th.Transform{p: l.g.t.p, s: th.Vf2{l.scale, l.scale}})

			stext = ""
			l.g.t.p.y += lineH * l.scale * 1.6
			if l.g.t.p.y + lineH*l.scale*1.8 > origY + l.g.t.s.y {
				return
			}
			w = 0
			continue
		}

		if text[i] == uint32(' ') {
			w += ^image.Image(l.font.runes.get(text[0])).getDims().x * l.scale * 1.1
		} else {
			dm := ^image.Image(l.font.runes.get(text[i])).getDims().x
			w += dm * l.scale * 1.1
			if h := dm; lineH == -1 || h > lineH {
				lineH = h
			}
		}

		stext += text[i].encode()
	}
}
