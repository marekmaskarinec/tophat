
import (
	"canvas.um"
	"coll.um"
	"input.um"
	"rect.um"
	"th.um"
)

type Style* = struct {
	backgroundColor: uint32
	textColor: uint32
	primaryColor: uint32
}

type Container* = interface {
	pushRect(r: rect.Rect): rect.Rect
	getDims(): rect.Rect
}

//~~struct Gui
type Gui* = struct {
	ctx: any
	scale: th.fu

	selection: int
	// contains more unexported fields
//~~
	idx: int
	
	isEval: bool
	style: []Style
	container: []Container
}

type LayoutFn* = fn(gui: ^Gui)

fn (this: ^Gui) pushStyle*(s: Style) {
	this.style = append(this.style, s)
}

fn (this: ^Gui) popStyle*() {
	if len(this.style) > 1 {
		this.style = slice(this.style, 0, len(this.style) - 1)
	}
}

fn (this: ^Gui) getStyle*(): Style {
	return this.style[len(this.style) - 1]
}

fn (this: ^Gui) pushContainer*(c: Container) {
	this.container = append(this.container, c)
}

fn (this: ^Gui) popContainer*() {
	if len(this.container) > 1 {
		this.container =
			slice(this.container, 0, len(this.container) - 1)
	}
}

fn (this: ^Gui) getContainer*(): Container {
	return this.container[len(this.container) - 1]
}

fn (this: ^Gui) pushRect*(r: rect.Rect): rect.Rect {
	return this.getContainer().pushRect(r)
}

fn (this: ^Gui) getDims*(): rect.Rect {
	return this.getContainer().getDims()
}

fn (this: ^Gui) rectToScreen(r: rect.Rect): rect.Rect {
	return rect.fromVf2(r.getPos().mulf(this.scale),
		r.getDims().mulf(this.scale))
}

fn (this: ^Gui) hover(r: rect.Rect): bool {
	return coll.vf2ToRect(input.getMousePos(), r)
}

fn (this: ^Gui) eval*(layout: LayoutFn) {
	this.isEval = true
	layout(this)
}

fn (this: ^Gui) draw*(layout: LayoutFn) {
	this.isEval = false
	layout(this)
}

type VBoxConfig* = struct { }

type VBox* = struct {
	rowH: th.fu
	dm: rect.Rect
	cfg: VBoxConfig
}

fn (this: ^VBox) pushRect(r: rect.Rect): rect.Rect {
	r.x = this.dm.x
	r.y = this.dm.y

	if r.h == 0 {
		r.h = this.rowH
	}

	if r.w == 0 {
		r.w = this.dm.w
	}

	this.dm.y += r.h
	return r
}

fn (this: ^VBox) getDims(): rect.Rect {
	return this.dm
}

fn (gui: ^Gui) vBox*(rowH: th.fu, cfg: VBoxConfig = VBoxConfig{}) {
	gui.pushContainer(VBox{
		rowH: rowH,
		dm: gui.pushRect(rect.Rect{}),
		cfg: cfg })
}


type RowConfig* = struct { }

type Row* = struct {
  subdivisions: uint
	dm: rect.Rect
	cfg: RowConfig
}

fn (this: ^Row) pushRect(r: rect.Rect): rect.Rect {
	r.x = this.dm.x
	r.y = this.dm.y
    
  step := this.dm.w/this.subdivisions
  r.w = step

	if r.h == 0 {
		r.h = this.dm.h
	}

  this.dm.x += step
	return r
}

fn (this: ^Row) getDims(): rect.Rect {
	return this.dm
}

fn (gui: ^Gui) row*(subdivisions: uint, cfg: RowConfig = RowConfig{}) {
  if (subdivisions == 0) {
    error("Invalid subdivision count")
  }
	gui.pushContainer(Row{
    subdivisions: subdivisions,
		dm: gui.pushRect(rect.Rect{}),
		cfg: cfg })
}



type StackConfig* = struct { }

type Stack* = struct {
	dm: rect.Rect
	cfg: StackConfig
}

fn (this: ^Stack) pushRect(r: rect.Rect): rect.Rect {
	return this.dm
}

fn (this: ^Stack) getDims(): rect.Rect {
	return this.dm
}

fn (gui: ^Gui) stack*(cfg: StackConfig = StackConfig{}) {
	gui.pushContainer(Stack{
		dm: gui.pushRect(rect.Rect{}),
		cfg: cfg })
}

type ButtonConfig* = struct {}

fn (gui: ^Gui) button*(cfg: ButtonConfig = ButtonConfig{}): bool {
	gui.stack()
	r := gui.getContainer().getDims()

	if gui.isEval {
		if gui.hover(r) && input.isJustReleased(input.mouse1) {
			return true
		}
		return false
	} else {
    canvas.drawRectLines(gui.getStyle().primaryColor,
      gui.rectToScreen(r),
      gui.scale)
  }

	return false
}

type LabelConfig* = struct {
  centerX: bool
  centerY: bool
  scale: th.fu
}

fn (gui: ^Gui) label*(text: str, cfg: LabelConfig = LabelConfig{scale: 1}) {
  gui.stack()
	r := gui.getContainer().getDims()
  style := gui.getStyle()

  x := r.x
  y := r.y
  txtSize := canvas.textSize(text, cfg.scale)
  if cfg.centerX {
    x += (r.w-txtSize.x)/2.0
  }
  if cfg.centerY {
    y += (r.h-txtSize.y)/2.0
  }
  
  if gui.isEval {
    canvas.drawText(text, th.Vf2{x, y}, 0x000000FF, cfg.scale)
  }
  gui.popContainer()
}

fn (gui: ^Gui) qbutton*(text: str, cfg: ButtonConfig = ButtonConfig{}): bool {
  pressed := gui.button()
  gui.label(text, LabelConfig{scale: 1, centerX: true, centerY: true})
  gui.popContainer()
  return pressed;
}

fn mk*(r: rect.Rect): Gui {
	gui := Gui{}
	gui.scale = 1
	gui.pushStyle(Style{
		backgroundColor: 0xccccccff,
		textColor: 0x000000ff,
		primaryColor: th.blue })
	gui.container = []Container{ Stack{ dm: r } }

	return gui
}
