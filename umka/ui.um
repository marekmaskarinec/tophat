
import (
	"canvas.um"
	"coll.um"
	"input.um"
	"rect.um"
	"th.um"
)

type Style* = struct {
	backgroundColor: uint32
	textColor: uint32
	primaryColor: uint32
}

type Container* = interface {
	pushRect(r: rect.Rect): rect.Rect
	getDims(): rect.Rect
}

//~~struct Gui
type Gui* = struct {
	ctx: any
	scale: th.fu

	selection: int
	// contains more unexported fields
//~~
	idx: int
	
	isEval: bool
	style: []Style
	container: []Container
}

type LayoutFn* = fn(gui: ^Gui)

fn (this: ^Gui) pushStyle*(s: Style) {
	this.style = append(this.style, s)
}

fn (this: ^Gui) popStyle*() {
	if len(this.style) > 1 {
		this.style = slice(this.style, 0, len(this.style) - 1)
	}
}

fn (this: ^Gui) getStyle*(): Style {
	return this.style[len(this.style) - 1]
}

fn (this: ^Gui) pushContainer*(c: Container) {
	this.container = append(this.container, c)
}

fn (this: ^Gui) popContainer*() {
	if len(this.container) > 1 {
		this.container =
			slice(this.container, 0, len(this.container) - 1)
	}
}

fn (this: ^Gui) getContainer*(): Container {
	return this.container[len(this.container) - 1]
}

fn (this: ^Gui) pushRect*(r: rect.Rect): rect.Rect {
	return this.getContainer().pushRect(r)
}

fn (this: ^Gui) getDims*(): rect.Rect {
	return this.getContainer().getDims()
}

fn (this: ^Gui) rectToScreen(r: rect.Rect): rect.Rect {
	return rect.fromVf2(r.getPos().mulf(this.scale),
		r.getDims().mulf(this.scale))
}

fn (this: ^Gui) hover(r: rect.Rect): bool {
	return coll.vf2ToRect(input.getMousePos(), r)
}

fn (this: ^Gui) eval*(layout: LayoutFn) {
	this.isEval = true
	layout(this)
}

fn (this: ^Gui) draw*(layout: LayoutFn) {
	this.isEval = false
	layout(this)
}

type VBoxConfig* = struct { }

type VBox* = struct {
	rowH: th.fu
	dm: rect.Rect
	cfg: VBoxConfig
}

fn (this: ^VBox) pushRect(r: rect.Rect): rect.Rect {
	r.x = this.dm.x
	r.y = this.dm.y

	if r.h == 0 {
		r.h = this.rowH
	}

	if r.w == 0 {
		r.w = this.dm.w
	}

	this.dm.y += r.h
	return r
}

fn (this: ^VBox) getDims(): rect.Rect {
	return this.dm
}

fn (gui: ^Gui) vBox*(rowH: th.fu, cfg: VBoxConfig = VBoxConfig{}) {
	gui.pushContainer(VBox{
		rowH: rowH,
		dm: gui.pushRect(rect.Rect{}),
		cfg: cfg })
}

type StackConfig* = struct { }

type Stack* = struct {
	dm: rect.Rect
	cfg: StackConfig
}

fn (this: ^Stack) pushRect(r: rect.Rect): rect.Rect {
	return this.dm
}

fn (this: ^Stack) getDims(): rect.Rect {
	return this.dm
}

fn (gui: ^Gui) stack*(cfg: StackConfig = StackConfig{}) {
	gui.pushContainer(Stack{
		dm: gui.pushRect(rect.Rect{}),
		cfg: cfg })
}

type ButtonConfig* = struct {}

fn (gui: ^Gui) button*(cfg: ButtonConfig = ButtonConfig{}): bool {
	gui.stack()
	r := gui.getContainer().getDims()

	if gui.isEval {
		if gui.hover(r) && input.isJustReleased(input.mouse1) {
			return true
		}
		return false
	}

	canvas.drawRectLines(gui.getStyle().primaryColor,
		gui.rectToScreen(r),
		gui.scale)

	return false
}

fn mk*(r: rect.Rect): Gui {
	gui := Gui{}
	gui.scale = 1
	gui.pushStyle(Style{
		backgroundColor: 0xcccccc,
		textColor: 0x0000000,
		primaryColor: th.blue })
	gui.container = []Container{ Stack{ dm: r } }

	return gui
}
