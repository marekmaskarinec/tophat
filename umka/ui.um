
import (
	"th.um"
	"vec.um"	
	"rect.um"
	"canvas.um"
)

type Generic* = struct {
	t: th.Transform
	onEvent: fn(evenType: th.uu, ctx: interface{})
	gridPos: th.Vf2
	gridSpan: th.Vf2
}

type Element* = interface {
	handle()
	draw()
	get(): ^Generic
}

type Grid* = struct {
	g: Generic
	w, h: th.uu
	elements: []Element
}

type SimpleLabel* = struct {
	g: Generic
	text: str
	textSize: th.fu
	color: uint32
	bgColor: uint32
}

fn (g: ^Generic) grid*(x, y: th.uu): ^Generic {
	g.gridPos.x = x
	g.gridPos.y = y
	return g
}

fn (g: ^Generic) span*(x, y: th.uu): ^Generic {
	g.gridSpan.x = x
	g.gridSpan.y = y
	return g
}

fn mkGrid*(w, h: th.uu): Grid {
	return Grid {
		g: Generic{},
		w: w, h: h,
		elements: []Element{}}
}

fn (g: ^Grid) get*(): ^Generic {
	return &g.g
}

fn (g: ^Grid) handle*() {
	cellSize := th.Vf2{g.g.t.s.x/g.w, g.g.t.s.y/g.h}

	for i:=0; i < len(g.elements); i++ {
		e := &g.elements[i]
		ge := e.get()

		if ge.gridPos.x > g.w || ge.gridPos.y > g.h {
			error("ui.Grid: out of bounds.")
		}

		ge.t.p = vec.mul(ge.gridPos, cellSize)

		if ge.gridPos.x + ge.gridSpan.x > g.w ||
			ge.gridPos.y + ge.gridSpan.y > g.h {
			error("ui.Grid: out of bounds.")
		}

		if ge.gridSpan.x == 0 {
			ge.gridSpan.x = 1
		}

		if ge.gridSpan.y == 0 {
			ge.gridSpan.y = 1
		}

		ge.t.s = vec.mul(ge.gridSpan, cellSize)

		e.handle()
	}
}

fn (g: ^Grid) draw*() {
	for e in g.elements {
		e.draw()
	}
}

fn mkSimpleLabel*(text: str, color: uint32, size: th.fu): SimpleLabel {
	return SimpleLabel {
		g: Generic{},
		text: text,
		textSize: size,
		color: color}
}

fn (l: ^SimpleLabel) get*(): ^Generic {
	return &l.g
}

fn (l: ^SimpleLabel) handle*() { }

fn (l: ^SimpleLabel) draw*() {
	canvas.setColor(l.bgColor)
	canvas.drawRect(rect.Rect{l.g.t.p.x, l.g.t.p.y, l.g.t.s.x, l.g.t.s.y})
	canvas.drawText(l.text, l.g.t.p, l.color, l.textSize)
}
